// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unreal_common.proto

#ifdef _MSC_VER
#	pragma warning(disable: 4125)
#	pragma warning(disable: 4647)
#	pragma warning(disable: 4668)
#	pragma warning(disable: 4800)
#	pragma warning(disable: 4946)
#endif

#include "unreal_common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace unrealpb {
PROTOBUF_CONSTEXPR FVector::FVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FVectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FVectorDefaultTypeInternal() {}
  union {
    FVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FVectorDefaultTypeInternal _FVector_default_instance_;
PROTOBUF_CONSTEXPR UnrealObjectRef_GuidCachedObject::UnrealObjectRef_GuidCachedObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pathname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.netguid_)*/0u
  , /*decltype(_impl_.outerguid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnrealObjectRef_GuidCachedObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnrealObjectRef_GuidCachedObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnrealObjectRef_GuidCachedObjectDefaultTypeInternal() {}
  union {
    UnrealObjectRef_GuidCachedObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnrealObjectRef_GuidCachedObjectDefaultTypeInternal _UnrealObjectRef_GuidCachedObject_default_instance_;
PROTOBUF_CONSTEXPR UnrealObjectRef::UnrealObjectRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.context_)*/{}
  , /*decltype(_impl_.netguidbunch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.netguid_)*/0u
  , /*decltype(_impl_.bunchbitsnum_)*/0u} {}
struct UnrealObjectRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnrealObjectRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnrealObjectRefDefaultTypeInternal() {}
  union {
    UnrealObjectRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnrealObjectRefDefaultTypeInternal _UnrealObjectRef_default_instance_;
PROTOBUF_CONSTEXPR ActorComponentRef::ActorComponentRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.compname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_)*/nullptr} {}
struct ActorComponentRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActorComponentRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActorComponentRefDefaultTypeInternal() {}
  union {
    ActorComponentRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActorComponentRefDefaultTypeInternal _ActorComponentRef_default_instance_;
PROTOBUF_CONSTEXPR RemoteFunctionMessage::RemoteFunctionMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.functionname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.paramspayload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.targetobj_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RemoteFunctionMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteFunctionMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteFunctionMessageDefaultTypeInternal() {}
  union {
    RemoteFunctionMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteFunctionMessageDefaultTypeInternal _RemoteFunctionMessage_default_instance_;
PROTOBUF_CONSTEXPR SpawnObjectMessage::SpawnObjectMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obj_)*/nullptr
  , /*decltype(_impl_.localrole_)*/0u} {}
struct SpawnObjectMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpawnObjectMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpawnObjectMessageDefaultTypeInternal() {}
  union {
    SpawnObjectMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpawnObjectMessageDefaultTypeInternal _SpawnObjectMessage_default_instance_;
PROTOBUF_CONSTEXPR ActorState::ActorState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_)*/nullptr
  , /*decltype(_impl_.instigator_)*/nullptr
  , /*decltype(_impl_.owningconnid_)*/0u
  , /*decltype(_impl_.localrole_)*/0u
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.breplicatemovement_)*/false
  , /*decltype(_impl_.bhidden_)*/false
  , /*decltype(_impl_.btearoff_)*/false
  , /*decltype(_impl_.remoterole_)*/0u
  , /*decltype(_impl_.bcanbedamaged_)*/false} {}
struct ActorStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActorStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActorStateDefaultTypeInternal() {}
  union {
    ActorState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActorStateDefaultTypeInternal _ActorState_default_instance_;
PROTOBUF_CONSTEXPR ActorComponentState::ActorComponentState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bisactive_)*/false
  , /*decltype(_impl_.breplicated_)*/false} {}
struct ActorComponentStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActorComponentStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActorComponentStateDefaultTypeInternal() {}
  union {
    ActorComponentState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActorComponentStateDefaultTypeInternal _ActorComponentState_default_instance_;
PROTOBUF_CONSTEXPR SceneComponentState::SceneComponentState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachchildren_)*/{}
  , /*decltype(_impl_.attachsocketname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attachparent_)*/nullptr
  , /*decltype(_impl_.relativelocation_)*/nullptr
  , /*decltype(_impl_.relativerotation_)*/nullptr
  , /*decltype(_impl_.relativescale_)*/nullptr
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.babsolutelocation_)*/false
  , /*decltype(_impl_.babsoluterotation_)*/false
  , /*decltype(_impl_.babsolutescale_)*/false
  , /*decltype(_impl_.bvisible_)*/false
  , /*decltype(_impl_.bshouldbeattached_)*/false
  , /*decltype(_impl_.bshouldsnaplocationwhenattached_)*/false
  , /*decltype(_impl_.bshouldsnaprotationwhenattached_)*/false} {}
struct SceneComponentStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SceneComponentStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SceneComponentStateDefaultTypeInternal() {}
  union {
    SceneComponentState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SceneComponentStateDefaultTypeInternal _SceneComponentState_default_instance_;
PROTOBUF_CONSTEXPR RootMotionMontage::RootMotionMontage(
    ::_pbi::ConstantInitialized) {}
struct RootMotionMontageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RootMotionMontageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RootMotionMontageDefaultTypeInternal() {}
  union {
    RootMotionMontage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RootMotionMontageDefaultTypeInternal _RootMotionMontage_default_instance_;
PROTOBUF_CONSTEXPR BasedMovementInfo::BasedMovementInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.movementbase_)*/nullptr
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.bserverhasbasecomponent_)*/false
  , /*decltype(_impl_.brelativerotation_)*/false
  , /*decltype(_impl_.bserverhasvelocity_)*/false} {}
struct BasedMovementInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BasedMovementInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BasedMovementInfoDefaultTypeInternal() {}
  union {
    BasedMovementInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BasedMovementInfoDefaultTypeInternal _BasedMovementInfo_default_instance_;
PROTOBUF_CONSTEXPR CharacterState::CharacterState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rootmotion_)*/nullptr
  , /*decltype(_impl_.basedmovement_)*/nullptr
  , /*decltype(_impl_.serverlasttransformupdatetimestamp_)*/0
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.biscrouched_)*/false
  , /*decltype(_impl_.bproxyisjumpforceapplied_)*/false
  , /*decltype(_impl_.movementmode_)*/0u
  , /*decltype(_impl_.animrootmotiontranslationscale_)*/0
  , /*decltype(_impl_.replaylasttransformupdatetimestamp_)*/0} {}
struct CharacterStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CharacterStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CharacterStateDefaultTypeInternal() {}
  union {
    CharacterState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CharacterStateDefaultTypeInternal _CharacterState_default_instance_;
PROTOBUF_CONSTEXPR Character_ServerMovePacked_Params::Character_ServerMovePacked_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.packedbits_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bitsnum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Character_ServerMovePacked_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Character_ServerMovePacked_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Character_ServerMovePacked_ParamsDefaultTypeInternal() {}
  union {
    Character_ServerMovePacked_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Character_ServerMovePacked_ParamsDefaultTypeInternal _Character_ServerMovePacked_Params_default_instance_;
PROTOBUF_CONSTEXPR Character_ClientMoveResponsePacked_Params::Character_ClientMoveResponsePacked_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.packedbits_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bitsnum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal() {}
  union {
    Character_ClientMoveResponsePacked_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal _Character_ClientMoveResponsePacked_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerState::PlayerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_.playerid_)*/0
  , /*decltype(_impl_.ping_)*/0u} {}
struct PlayerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerStateDefaultTypeInternal() {}
  union {
    PlayerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
PROTOBUF_CONSTEXPR ControllerState::ControllerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.playerstate_)*/nullptr
  , /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControllerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControllerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControllerStateDefaultTypeInternal() {}
  union {
    ControllerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControllerStateDefaultTypeInternal _ControllerState_default_instance_;
PROTOBUF_CONSTEXPR Controller_ClientSetLocation_Params::Controller_ClientSetLocation_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newlocation_)*/nullptr
  , /*decltype(_impl_.newrotation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Controller_ClientSetLocation_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Controller_ClientSetLocation_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Controller_ClientSetLocation_ParamsDefaultTypeInternal() {}
  union {
    Controller_ClientSetLocation_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Controller_ClientSetLocation_ParamsDefaultTypeInternal _Controller_ClientSetLocation_Params_default_instance_;
PROTOBUF_CONSTEXPR Controller_ClientSetRotation_Params::Controller_ClientSetRotation_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newrotation_)*/nullptr
  , /*decltype(_impl_.bresetcamera_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Controller_ClientSetRotation_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Controller_ClientSetRotation_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Controller_ClientSetRotation_ParamsDefaultTypeInternal() {}
  union {
    Controller_ClientSetRotation_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Controller_ClientSetRotation_ParamsDefaultTypeInternal _Controller_ClientSetRotation_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerControllerState::PlayerControllerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.targetviewrotation_)*/nullptr
  , /*decltype(_impl_.spawnlocation_)*/nullptr
  , /*decltype(_impl_.removed_)*/false} {}
struct PlayerControllerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerControllerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerControllerStateDefaultTypeInternal() {}
  union {
    PlayerControllerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerControllerStateDefaultTypeInternal _PlayerControllerState_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ServerUpdateCamera_Params::PlayerController_ServerUpdateCamera_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.camloc_)*/nullptr
  , /*decltype(_impl_.campitchandyaw_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ServerUpdateCamera_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal _PlayerController_ServerUpdateCamera_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientSetHUD_Params::PlayerController_ClientSetHUD_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hudclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PlayerController_ClientSetHUD_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientSetHUD_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientSetHUD_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientSetHUD_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientSetHUD_ParamsDefaultTypeInternal _PlayerController_ClientSetHUD_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientSetViewTarget_Params::PlayerController_ClientSetViewTarget_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actor_)*/nullptr
  , /*decltype(_impl_.blendtime_)*/0
  , /*decltype(_impl_.blendfunction_)*/0u
  , /*decltype(_impl_.blendexp_)*/0
  , /*decltype(_impl_.blockoutgoing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientSetViewTarget_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal _PlayerController_ClientSetViewTarget_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientEnableNetworkVoice_Params::PlayerController_ClientEnableNetworkVoice_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.benable_)*/false} {}
struct PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientEnableNetworkVoice_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal _PlayerController_ClientEnableNetworkVoice_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientCapBandwidth_Params::PlayerController_ClientCapBandwidth_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cap_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientCapBandwidth_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal _PlayerController_ClientCapBandwidth_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientRestart_Params::PlayerController_ClientRestart_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientRestart_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientRestart_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientRestart_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientRestart_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientRestart_ParamsDefaultTypeInternal _PlayerController_ClientRestart_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientSetCameraMode_Params::PlayerController_ClientSetCameraMode_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newcammode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientSetCameraMode_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal _PlayerController_ClientSetCameraMode_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientRetryClientRestart_Params::PlayerController_ClientRetryClientRestart_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientRetryClientRestart_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal _PlayerController_ClientRetryClientRestart_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ServerSetSpectatorLocation_Params::PlayerController_ServerSetSpectatorLocation_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newloc_)*/nullptr
  , /*decltype(_impl_.newrot_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ServerSetSpectatorLocation_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal _PlayerController_ServerSetSpectatorLocation_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ServerAcknowledgePossession_Params::PlayerController_ServerAcknowledgePossession_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ServerAcknowledgePossession_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal _PlayerController_ServerAcknowledgePossession_Params_default_instance_;
PROTOBUF_CONSTEXPR GameStateBase::GameStateBase(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.spectatorclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gamemodeclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.breplicatedhasbegunplay_)*/false
  , /*decltype(_impl_.replicatedworldtimeseconds_)*/0} {}
struct GameStateBaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameStateBaseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameStateBaseDefaultTypeInternal() {}
  union {
    GameStateBase _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameStateBaseDefaultTypeInternal _GameStateBase_default_instance_;
}  // namespace unrealpb
static ::_pb::Metadata file_level_metadata_unreal_5fcommon_2eproto[30];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_unreal_5fcommon_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_unreal_5fcommon_2eproto = nullptr;

const uint32_t TableStruct_unreal_5fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _impl_.netguid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _impl_.pathname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _impl_.outerguid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.netguid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.netguidbunch_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.bunchbitsnum_),
  1,
  ~0u,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _impl_.compname_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _impl_.targetobj_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _impl_.functionname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _impl_.paramspayload_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_.obj_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_.localrole_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.owningconnid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.breplicatemovement_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.localrole_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.remoterole_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.bhidden_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.btearoff_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.bcanbedamaged_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.instigator_),
  ~0u,
  2,
  4,
  3,
  7,
  0,
  5,
  6,
  8,
  1,
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_.bisactive_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_.breplicated_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.babsolutelocation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.babsoluterotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.babsolutescale_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bvisible_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bshouldbeattached_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bshouldsnaplocationwhenattached_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bshouldsnaprotationwhenattached_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.attachparent_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.attachchildren_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.attachsocketname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.relativelocation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.relativerotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.relativescale_),
  ~0u,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  1,
  ~0u,
  0,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::RootMotionMontage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.movementbase_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.bonename_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.bserverhasbasecomponent_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.brelativerotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::BasedMovementInfo, _impl_.bserverhasvelocity_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.rootmotion_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.basedmovement_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.serverlasttransformupdatetimestamp_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.movementmode_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.biscrouched_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.bproxyisjumpforceapplied_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.animrootmotiontranslationscale_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.replaylasttransformupdatetimestamp_),
  ~0u,
  0,
  1,
  2,
  5,
  3,
  4,
  6,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ServerMovePacked_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ServerMovePacked_Params, _impl_.bitsnum_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ServerMovePacked_Params, _impl_.packedbits_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ClientMoveResponsePacked_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ClientMoveResponsePacked_Params, _impl_.bitsnum_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ClientMoveResponsePacked_Params, _impl_.packedbits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.ping_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.playername_),
  ~0u,
  1,
  2,
  3,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _impl_.playerstate_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetLocation_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetLocation_Params, _impl_.newlocation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetLocation_Params, _impl_.newrotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetRotation_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetRotation_Params, _impl_.newrotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetRotation_Params, _impl_.bresetcamera_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_.targetviewrotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_.spawnlocation_),
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerUpdateCamera_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerUpdateCamera_Params, _impl_.camloc_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerUpdateCamera_Params, _impl_.campitchandyaw_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetHUD_Params, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetHUD_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetHUD_Params, _impl_.hudclassname_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.actor_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blendtime_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blendfunction_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blendexp_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blockoutgoing_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params, _impl_.benable_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientCapBandwidth_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientCapBandwidth_Params, _impl_.cap_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRestart_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRestart_Params, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetCameraMode_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetCameraMode_Params, _impl_.newcammode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRetryClientRestart_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRetryClientRestart_Params, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params, _impl_.newloc_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params, _impl_.newrot_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerAcknowledgePossession_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerAcknowledgePossession_Params, _impl_.pawn_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.spectatorclassname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.gamemodeclassname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.replicatedworldtimeseconds_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.breplicatedhasbegunplay_),
  ~0u,
  0,
  1,
  3,
  2,
};
static const ::_pbi::MigrationSchema schemas_unreal_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::unrealpb::FVector)},
  { 9, -1, -1, sizeof(::unrealpb::UnrealObjectRef_GuidCachedObject)},
  { 18, 28, -1, sizeof(::unrealpb::UnrealObjectRef)},
  { 32, 40, -1, sizeof(::unrealpb::ActorComponentRef)},
  { 42, -1, -1, sizeof(::unrealpb::RemoteFunctionMessage)},
  { 51, 59, -1, sizeof(::unrealpb::SpawnObjectMessage)},
  { 61, 77, -1, sizeof(::unrealpb::ActorState)},
  { 87, 95, -1, sizeof(::unrealpb::ActorComponentState)},
  { 97, 117, -1, sizeof(::unrealpb::SceneComponentState)},
  { 131, -1, -1, sizeof(::unrealpb::RootMotionMontage)},
  { 137, 150, -1, sizeof(::unrealpb::BasedMovementInfo)},
  { 157, 172, -1, sizeof(::unrealpb::CharacterState)},
  { 181, -1, -1, sizeof(::unrealpb::Character_ServerMovePacked_Params)},
  { 189, -1, -1, sizeof(::unrealpb::Character_ClientMoveResponsePacked_Params)},
  { 197, 208, -1, sizeof(::unrealpb::PlayerState)},
  { 213, -1, -1, sizeof(::unrealpb::ControllerState)},
  { 222, -1, -1, sizeof(::unrealpb::Controller_ClientSetLocation_Params)},
  { 230, -1, -1, sizeof(::unrealpb::Controller_ClientSetRotation_Params)},
  { 238, 247, -1, sizeof(::unrealpb::PlayerControllerState)},
  { 250, -1, -1, sizeof(::unrealpb::PlayerController_ServerUpdateCamera_Params)},
  { 258, 265, -1, sizeof(::unrealpb::PlayerController_ClientSetHUD_Params)},
  { 266, -1, -1, sizeof(::unrealpb::PlayerController_ClientSetViewTarget_Params)},
  { 277, 284, -1, sizeof(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params)},
  { 285, -1, -1, sizeof(::unrealpb::PlayerController_ClientCapBandwidth_Params)},
  { 292, -1, -1, sizeof(::unrealpb::PlayerController_ClientRestart_Params)},
  { 299, -1, -1, sizeof(::unrealpb::PlayerController_ClientSetCameraMode_Params)},
  { 306, -1, -1, sizeof(::unrealpb::PlayerController_ClientRetryClientRestart_Params)},
  { 313, -1, -1, sizeof(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params)},
  { 321, -1, -1, sizeof(::unrealpb::PlayerController_ServerAcknowledgePossession_Params)},
  { 328, 339, -1, sizeof(::unrealpb::GameStateBase)},
};

static const ::_pb::Message* const file_default_instances_unreal_5fcommon_2eproto[] = {
  &::unrealpb::_FVector_default_instance_._instance,
  &::unrealpb::_UnrealObjectRef_GuidCachedObject_default_instance_._instance,
  &::unrealpb::_UnrealObjectRef_default_instance_._instance,
  &::unrealpb::_ActorComponentRef_default_instance_._instance,
  &::unrealpb::_RemoteFunctionMessage_default_instance_._instance,
  &::unrealpb::_SpawnObjectMessage_default_instance_._instance,
  &::unrealpb::_ActorState_default_instance_._instance,
  &::unrealpb::_ActorComponentState_default_instance_._instance,
  &::unrealpb::_SceneComponentState_default_instance_._instance,
  &::unrealpb::_RootMotionMontage_default_instance_._instance,
  &::unrealpb::_BasedMovementInfo_default_instance_._instance,
  &::unrealpb::_CharacterState_default_instance_._instance,
  &::unrealpb::_Character_ServerMovePacked_Params_default_instance_._instance,
  &::unrealpb::_Character_ClientMoveResponsePacked_Params_default_instance_._instance,
  &::unrealpb::_PlayerState_default_instance_._instance,
  &::unrealpb::_ControllerState_default_instance_._instance,
  &::unrealpb::_Controller_ClientSetLocation_Params_default_instance_._instance,
  &::unrealpb::_Controller_ClientSetRotation_Params_default_instance_._instance,
  &::unrealpb::_PlayerControllerState_default_instance_._instance,
  &::unrealpb::_PlayerController_ServerUpdateCamera_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientSetHUD_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientSetViewTarget_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientEnableNetworkVoice_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientCapBandwidth_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientRestart_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientSetCameraMode_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientRetryClientRestart_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ServerSetSpectatorLocation_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ServerAcknowledgePossession_Params_default_instance_._instance,
  &::unrealpb::_GameStateBase_default_instance_._instance,
};

const char descriptor_table_protodef_unreal_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023unreal_common.proto\022\010unrealpb\"*\n\007FVect"
  "or\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"\222\002\n\017"
  "UnrealObjectRef\022\024\n\007netGUID\030\001 \001(\rH\000\210\001\001\022;\n"
  "\007context\030\002 \003(\0132*.unrealpb.UnrealObjectRe"
  "f.GuidCachedObject\022\031\n\014netGUIDBunch\030\003 \001(\014"
  "H\001\210\001\001\022\031\n\014bunchBitsNum\030\004 \001(\rH\002\210\001\001\032H\n\020Guid"
  "CachedObject\022\017\n\007netGUID\030\001 \001(\r\022\020\n\010pathNam"
  "e\030\002 \001(\t\022\021\n\touterGUID\030\003 \001(\rB\n\n\010_netGUIDB\017"
  "\n\r_netGUIDBunchB\017\n\r_bunchBitsNum\"p\n\021Acto"
  "rComponentRef\022-\n\005owner\030\001 \001(\0132\031.unrealpb."
  "UnrealObjectRefH\000\210\001\001\022\025\n\010compName\030\002 \001(\tH\001"
  "\210\001\001B\010\n\006_ownerB\013\n\t_compName\"r\n\025RemoteFunc"
  "tionMessage\022,\n\ttargetObj\030\001 \001(\0132\031.unrealp"
  "b.UnrealObjectRef\022\024\n\014functionName\030\002 \001(\t\022"
  "\025\n\rparamsPayload\030\003 \001(\014\"b\n\022SpawnObjectMes"
  "sage\022&\n\003obj\030\001 \001(\0132\031.unrealpb.UnrealObjec"
  "tRef\022\026\n\tlocalRole\030\002 \001(\rH\000\210\001\001B\014\n\n_localRo"
  "le\"\277\003\n\nActorState\022\017\n\007removed\030\001 \001(\010\022\031\n\014ow"
  "ningConnId\030\002 \001(\rH\000\210\001\001\022\037\n\022bReplicateMovem"
  "ent\030\003 \001(\010H\001\210\001\001\022\026\n\tlocalRole\030\004 \001(\rH\002\210\001\001\022\027"
  "\n\nremoteRole\030\005 \001(\rH\003\210\001\001\022-\n\005owner\030\006 \001(\0132\031"
  ".unrealpb.UnrealObjectRefH\004\210\001\001\022\024\n\007bHidde"
  "n\030\007 \001(\010H\005\210\001\001\022\025\n\010bTearOff\030\010 \001(\010H\006\210\001\001\022\032\n\rb"
  "CanBeDamaged\030\t \001(\010H\007\210\001\001\0222\n\ninstigator\030\n "
  "\001(\0132\031.unrealpb.UnrealObjectRefH\010\210\001\001B\017\n\r_"
  "owningConnIdB\025\n\023_bReplicateMovementB\014\n\n_"
  "localRoleB\r\n\013_remoteRoleB\010\n\006_ownerB\n\n\010_b"
  "HiddenB\013\n\t_bTearOffB\020\n\016_bCanBeDamagedB\r\n"
  "\013_instigator\"e\n\023ActorComponentState\022\026\n\tb"
  "IsActive\030\001 \001(\010H\000\210\001\001\022\030\n\013bReplicated\030\002 \001(\010"
  "H\001\210\001\001B\014\n\n_bIsActiveB\016\n\014_bReplicated\"\275\006\n\023"
  "SceneComponentState\022\017\n\007removed\030\001 \001(\010\022\036\n\021"
  "bAbsoluteLocation\030\002 \001(\010H\000\210\001\001\022\036\n\021bAbsolut"
  "eRotation\030\003 \001(\010H\001\210\001\001\022\033\n\016bAbsoluteScale\030\004"
  " \001(\010H\002\210\001\001\022\025\n\010bVisible\030\005 \001(\010H\003\210\001\001\022\036\n\021bSho"
  "uldBeAttached\030\006 \001(\010H\004\210\001\001\022,\n\037bShouldSnapL"
  "ocationWhenAttached\030\007 \001(\010H\005\210\001\001\022,\n\037bShoul"
  "dSnapRotationWhenAttached\030\010 \001(\010H\006\210\001\001\0224\n\014"
  "attachParent\030\t \001(\0132\031.unrealpb.UnrealObje"
  "ctRefH\007\210\001\001\0221\n\016attachChildren\030\n \003(\0132\031.unr"
  "ealpb.UnrealObjectRef\022\035\n\020attachSocketNam"
  "e\030\013 \001(\tH\010\210\001\001\0220\n\020relativeLocation\030\014 \001(\0132\021"
  ".unrealpb.FVectorH\t\210\001\001\0220\n\020relativeRotati"
  "on\030\r \001(\0132\021.unrealpb.FVectorH\n\210\001\001\022-\n\rrela"
  "tiveScale\030\016 \001(\0132\021.unrealpb.FVectorH\013\210\001\001B"
  "\024\n\022_bAbsoluteLocationB\024\n\022_bAbsoluteRotat"
  "ionB\021\n\017_bAbsoluteScaleB\013\n\t_bVisibleB\024\n\022_"
  "bShouldBeAttachedB\"\n _bShouldSnapLocatio"
  "nWhenAttachedB\"\n _bShouldSnapRotationWhe"
  "nAttachedB\017\n\r_attachParentB\023\n\021_attachSoc"
  "ketNameB\023\n\021_relativeLocationB\023\n\021_relativ"
  "eRotationB\020\n\016_relativeScale\"\023\n\021RootMotio"
  "nMontage\"\236\003\n\021BasedMovementInfo\0226\n\014moveme"
  "ntBase\030\001 \001(\0132\033.unrealpb.ActorComponentRe"
  "fH\000\210\001\001\022\025\n\010boneName\030\002 \001(\tH\001\210\001\001\022(\n\010locatio"
  "n\030\003 \001(\0132\021.unrealpb.FVectorH\002\210\001\001\022(\n\010rotat"
  "ion\030\004 \001(\0132\021.unrealpb.FVectorH\003\210\001\001\022$\n\027bSe"
  "rverHasBaseComponent\030\005 \001(\010H\004\210\001\001\022\036\n\021bRela"
  "tiveRotation\030\006 \001(\010H\005\210\001\001\022\037\n\022bServerHasVel"
  "ocity\030\007 \001(\010H\006\210\001\001B\017\n\r_movementBaseB\013\n\t_bo"
  "neNameB\013\n\t_locationB\013\n\t_rotationB\032\n\030_bSe"
  "rverHasBaseComponentB\024\n\022_bRelativeRotati"
  "onB\025\n\023_bServerHasVelocity\"\313\004\n\016CharacterS"
  "tate\022\017\n\007removed\030\001 \001(\010\0224\n\nrootMotion\030\002 \001("
  "\0132\033.unrealpb.RootMotionMontageH\000\210\001\001\0227\n\rb"
  "asedMovement\030\003 \001(\0132\033.unrealpb.BasedMovem"
  "entInfoH\001\210\001\001\022/\n\"serverLastTransformUpdat"
  "eTimeStamp\030\004 \001(\002H\002\210\001\001\022\031\n\014movementMode\030\005 "
  "\001(\rH\003\210\001\001\022\030\n\013bIsCrouched\030\006 \001(\010H\004\210\001\001\022%\n\030bP"
  "roxyIsJumpForceApplied\030\007 \001(\010H\005\210\001\001\022+\n\036ani"
  "mRootMotionTranslationScale\030\010 \001(\002H\006\210\001\001\022/"
  "\n\"replayLastTransformUpdateTimeStamp\030\t \001"
  "(\002H\007\210\001\001B\r\n\013_rootMotionB\020\n\016_basedMovement"
  "B%\n#_serverLastTransformUpdateTimeStampB"
  "\017\n\r_movementModeB\016\n\014_bIsCrouchedB\033\n\031_bPr"
  "oxyIsJumpForceAppliedB!\n\037_animRootMotion"
  "TranslationScaleB%\n#_replayLastTransform"
  "UpdateTimeStamp\"H\n!Character_ServerMoveP"
  "acked_Params\022\017\n\007bitsNum\030\001 \001(\r\022\022\n\npackedB"
  "its\030\002 \001(\014\"P\n)Character_ClientMoveRespons"
  "ePacked_Params\022\017\n\007bitsNum\030\001 \001(\r\022\022\n\npacke"
  "dBits\030\002 \001(\014\"\244\001\n\013PlayerState\022\017\n\007removed\030\001"
  " \001(\010\022\022\n\005score\030\002 \001(\002H\000\210\001\001\022\025\n\010playerId\030\003 \001"
  "(\005H\001\210\001\001\022\021\n\004ping\030\004 \001(\rH\002\210\001\001\022\027\n\nplayerName"
  "\030\005 \001(\tH\003\210\001\001B\010\n\006_scoreB\013\n\t_playerIdB\007\n\005_p"
  "ingB\r\n\013_playerName\"{\n\017ControllerState\022\017\n"
  "\007removed\030\001 \001(\010\022.\n\013playerState\030\002 \001(\0132\031.un"
  "realpb.UnrealObjectRef\022\'\n\004pawn\030\003 \001(\0132\031.u"
  "nrealpb.UnrealObjectRef\"u\n#Controller_Cl"
  "ientSetLocation_Params\022&\n\013newLocation\030\001 "
  "\001(\0132\021.unrealpb.FVector\022&\n\013newRotation\030\002 "
  "\001(\0132\021.unrealpb.FVector\"c\n#Controller_Cli"
  "entSetRotation_Params\022&\n\013newRotation\030\001 \001"
  "(\0132\021.unrealpb.FVector\022\024\n\014bResetCamera\030\002 "
  "\001(\010\"\264\001\n\025PlayerControllerState\022\017\n\007removed"
  "\030\001 \001(\010\0222\n\022targetViewRotation\030\002 \001(\0132\021.unr"
  "ealpb.FVectorH\000\210\001\001\022-\n\rspawnLocation\030\003 \001("
  "\0132\021.unrealpb.FVectorH\001\210\001\001B\025\n\023_targetView"
  "RotationB\020\n\016_spawnLocation\"g\n*PlayerCont"
  "roller_ServerUpdateCamera_Params\022!\n\006camL"
  "oc\030\001 \001(\0132\021.unrealpb.FVector\022\026\n\016camPitchA"
  "ndYaw\030\002 \001(\005\"R\n$PlayerController_ClientSe"
  "tHUD_Params\022\031\n\014hudClassName\030\001 \001(\tH\000\210\001\001B\017"
  "\n\r_hudClassName\"\252\001\n+PlayerController_Cli"
  "entSetViewTarget_Params\022(\n\005actor\030\001 \001(\0132\031"
  ".unrealpb.UnrealObjectRef\022\021\n\tblendTime\030\002"
  " \001(\002\022\025\n\rblendFunction\030\003 \001(\r\022\020\n\010blendExp\030"
  "\004 \001(\002\022\025\n\rbLockOutgoing\030\005 \001(\010\"T\n0PlayerCo"
  "ntroller_ClientEnableNetworkVoice_Params"
  "\022\024\n\007bEnable\030\001 \001(\010H\000\210\001\001B\n\n\010_bEnable\"9\n*Pl"
  "ayerController_ClientCapBandwidth_Params"
  "\022\013\n\003cap\030\001 \001(\005\"P\n%PlayerController_Client"
  "Restart_Params\022\'\n\004pawn\030\001 \001(\0132\031.unrealpb."
  "UnrealObjectRef\"A\n+PlayerController_Clie"
  "ntSetCameraMode_Params\022\022\n\nnewCamMode\030\001 \001"
  "(\t\"[\n0PlayerController_ClientRetryClient"
  "Restart_Params\022\'\n\004pawn\030\001 \001(\0132\031.unrealpb."
  "UnrealObjectRef\"z\n2PlayerController_Serv"
  "erSetSpectatorLocation_Params\022!\n\006newLoc\030"
  "\001 \001(\0132\021.unrealpb.FVector\022!\n\006newRot\030\002 \001(\013"
  "2\021.unrealpb.FVector\"^\n3PlayerController_"
  "ServerAcknowledgePossession_Params\022\'\n\004pa"
  "wn\030\001 \001(\0132\031.unrealpb.UnrealObjectRef\"\230\002\n\r"
  "GameStateBase\022\017\n\007removed\030\001 \001(\010\022\037\n\022specta"
  "torClassName\030\002 \001(\tH\000\210\001\001\022\036\n\021gameModeClass"
  "Name\030\003 \001(\tH\001\210\001\001\022\'\n\032replicatedWorldTimeSe"
  "conds\030\004 \001(\002H\002\210\001\001\022$\n\027bReplicatedHasBegunP"
  "lay\030\005 \001(\010H\003\210\001\001B\025\n\023_spectatorClassNameB\024\n"
  "\022_gameModeClassNameB\035\n\033_replicatedWorldT"
  "imeSecondsB\032\n\030_bReplicatedHasBegunPlayB,"
  "Z*channeld.clewcat.com/channeld/pkg/unre"
  "alpbb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_unreal_5fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_unreal_5fcommon_2eproto = {
    false, false, 5252, descriptor_table_protodef_unreal_5fcommon_2eproto,
    "unreal_common.proto",
    &descriptor_table_unreal_5fcommon_2eproto_once, nullptr, 0, 30,
    schemas_unreal_5fcommon_2eproto, file_default_instances_unreal_5fcommon_2eproto, TableStruct_unreal_5fcommon_2eproto::offsets,
    file_level_metadata_unreal_5fcommon_2eproto, file_level_enum_descriptors_unreal_5fcommon_2eproto,
    file_level_service_descriptors_unreal_5fcommon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_unreal_5fcommon_2eproto_getter() {
  return &descriptor_table_unreal_5fcommon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_unreal_5fcommon_2eproto(&descriptor_table_unreal_5fcommon_2eproto);
namespace unrealpb {

// ===================================================================

class FVector::_Internal {
 public:
};

FVector::FVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FVector)
}
FVector::FVector(const FVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FVector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FVector)
}

inline void FVector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FVector::~FVector() {
  // @@protoc_insertion_point(destructor:unrealpb.FVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FVector::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FVector)
  return target;
}

size_t FVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FVector::GetClassData() const { return &_class_data_; }


void FVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FVector*>(&to_msg);
  auto& from = static_cast<const FVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FVector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FVector::CopyFrom(const FVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FVector::IsInitialized() const {
  return true;
}

void FVector::InternalSwap(FVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FVector, _impl_.z_)
      + sizeof(FVector::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(FVector, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[0]);
}

// ===================================================================

class UnrealObjectRef_GuidCachedObject::_Internal {
 public:
};

UnrealObjectRef_GuidCachedObject::UnrealObjectRef_GuidCachedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.UnrealObjectRef.GuidCachedObject)
}
UnrealObjectRef_GuidCachedObject::UnrealObjectRef_GuidCachedObject(const UnrealObjectRef_GuidCachedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnrealObjectRef_GuidCachedObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pathname_){}
    , decltype(_impl_.netguid_){}
    , decltype(_impl_.outerguid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pathname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pathname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pathname().empty()) {
    _this->_impl_.pathname_.Set(from._internal_pathname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.netguid_, &from._impl_.netguid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.outerguid_) -
    reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.outerguid_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.UnrealObjectRef.GuidCachedObject)
}

inline void UnrealObjectRef_GuidCachedObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pathname_){}
    , decltype(_impl_.netguid_){0u}
    , decltype(_impl_.outerguid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pathname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pathname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnrealObjectRef_GuidCachedObject::~UnrealObjectRef_GuidCachedObject() {
  // @@protoc_insertion_point(destructor:unrealpb.UnrealObjectRef.GuidCachedObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnrealObjectRef_GuidCachedObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pathname_.Destroy();
}

void UnrealObjectRef_GuidCachedObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnrealObjectRef_GuidCachedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pathname_.ClearToEmpty();
  ::memset(&_impl_.netguid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.outerguid_) -
      reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.outerguid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnrealObjectRef_GuidCachedObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 netGUID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.netguid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string pathName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pathname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.UnrealObjectRef.GuidCachedObject.pathName"));
        } else
          goto handle_unusual;
        continue;
      // uint32 outerGUID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.outerguid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnrealObjectRef_GuidCachedObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 netGUID = 1;
  if (this->_internal_netguid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netguid(), target);
  }

  // string pathName = 2;
  if (!this->_internal_pathname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pathname().data(), static_cast<int>(this->_internal_pathname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.UnrealObjectRef.GuidCachedObject.pathName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pathname(), target);
  }

  // uint32 outerGUID = 3;
  if (this->_internal_outerguid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_outerguid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.UnrealObjectRef.GuidCachedObject)
  return target;
}

size_t UnrealObjectRef_GuidCachedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pathName = 2;
  if (!this->_internal_pathname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pathname());
  }

  // uint32 netGUID = 1;
  if (this->_internal_netguid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netguid());
  }

  // uint32 outerGUID = 3;
  if (this->_internal_outerguid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_outerguid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnrealObjectRef_GuidCachedObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnrealObjectRef_GuidCachedObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnrealObjectRef_GuidCachedObject::GetClassData() const { return &_class_data_; }


void UnrealObjectRef_GuidCachedObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnrealObjectRef_GuidCachedObject*>(&to_msg);
  auto& from = static_cast<const UnrealObjectRef_GuidCachedObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pathname().empty()) {
    _this->_internal_set_pathname(from._internal_pathname());
  }
  if (from._internal_netguid() != 0) {
    _this->_internal_set_netguid(from._internal_netguid());
  }
  if (from._internal_outerguid() != 0) {
    _this->_internal_set_outerguid(from._internal_outerguid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnrealObjectRef_GuidCachedObject::CopyFrom(const UnrealObjectRef_GuidCachedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnrealObjectRef_GuidCachedObject::IsInitialized() const {
  return true;
}

void UnrealObjectRef_GuidCachedObject::InternalSwap(UnrealObjectRef_GuidCachedObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pathname_, lhs_arena,
      &other->_impl_.pathname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnrealObjectRef_GuidCachedObject, _impl_.outerguid_)
      + sizeof(UnrealObjectRef_GuidCachedObject::_impl_.outerguid_)
      - PROTOBUF_FIELD_OFFSET(UnrealObjectRef_GuidCachedObject, _impl_.netguid_)>(
          reinterpret_cast<char*>(&_impl_.netguid_),
          reinterpret_cast<char*>(&other->_impl_.netguid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnrealObjectRef_GuidCachedObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[1]);
}

// ===================================================================

class UnrealObjectRef::_Internal {
 public:
  using HasBits = decltype(std::declval<UnrealObjectRef>()._impl_._has_bits_);
  static void set_has_netguid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_netguidbunch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bunchbitsnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UnrealObjectRef::UnrealObjectRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.UnrealObjectRef)
}
UnrealObjectRef::UnrealObjectRef(const UnrealObjectRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnrealObjectRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.context_){from._impl_.context_}
    , decltype(_impl_.netguidbunch_){}
    , decltype(_impl_.netguid_){}
    , decltype(_impl_.bunchbitsnum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.netguidbunch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.netguidbunch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_netguidbunch()) {
    _this->_impl_.netguidbunch_.Set(from._internal_netguidbunch(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.netguid_, &from._impl_.netguid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bunchbitsnum_) -
    reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.bunchbitsnum_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.UnrealObjectRef)
}

inline void UnrealObjectRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.context_){arena}
    , decltype(_impl_.netguidbunch_){}
    , decltype(_impl_.netguid_){0u}
    , decltype(_impl_.bunchbitsnum_){0u}
  };
  _impl_.netguidbunch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.netguidbunch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnrealObjectRef::~UnrealObjectRef() {
  // @@protoc_insertion_point(destructor:unrealpb.UnrealObjectRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnrealObjectRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.context_.~RepeatedPtrField();
  _impl_.netguidbunch_.Destroy();
}

void UnrealObjectRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnrealObjectRef::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.UnrealObjectRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.context_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.netguidbunch_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.netguid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bunchbitsnum_) -
        reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.bunchbitsnum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnrealObjectRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 netGUID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_netguid(&has_bits);
          _impl_.netguid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unrealpb.UnrealObjectRef.GuidCachedObject context = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_context(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes netGUIDBunch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_netguidbunch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bunchBitsNum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bunchbitsnum(&has_bits);
          _impl_.bunchbitsnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnrealObjectRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.UnrealObjectRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 netGUID = 1;
  if (_internal_has_netguid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netguid(), target);
  }

  // repeated .unrealpb.UnrealObjectRef.GuidCachedObject context = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_context_size()); i < n; i++) {
    const auto& repfield = this->_internal_context(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes netGUIDBunch = 3;
  if (_internal_has_netguidbunch()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_netguidbunch(), target);
  }

  // optional uint32 bunchBitsNum = 4;
  if (_internal_has_bunchbitsnum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bunchbitsnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.UnrealObjectRef)
  return target;
}

size_t UnrealObjectRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.UnrealObjectRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.UnrealObjectRef.GuidCachedObject context = 2;
  total_size += 1UL * this->_internal_context_size();
  for (const auto& msg : this->_impl_.context_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes netGUIDBunch = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_netguidbunch());
    }

    // optional uint32 netGUID = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netguid());
    }

    // optional uint32 bunchBitsNum = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bunchbitsnum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnrealObjectRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnrealObjectRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnrealObjectRef::GetClassData() const { return &_class_data_; }


void UnrealObjectRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnrealObjectRef*>(&to_msg);
  auto& from = static_cast<const UnrealObjectRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.UnrealObjectRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.context_.MergeFrom(from._impl_.context_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_netguidbunch(from._internal_netguidbunch());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.netguid_ = from._impl_.netguid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bunchbitsnum_ = from._impl_.bunchbitsnum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnrealObjectRef::CopyFrom(const UnrealObjectRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.UnrealObjectRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnrealObjectRef::IsInitialized() const {
  return true;
}

void UnrealObjectRef::InternalSwap(UnrealObjectRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.context_.InternalSwap(&other->_impl_.context_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.netguidbunch_, lhs_arena,
      &other->_impl_.netguidbunch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnrealObjectRef, _impl_.bunchbitsnum_)
      + sizeof(UnrealObjectRef::_impl_.bunchbitsnum_)
      - PROTOBUF_FIELD_OFFSET(UnrealObjectRef, _impl_.netguid_)>(
          reinterpret_cast<char*>(&_impl_.netguid_),
          reinterpret_cast<char*>(&other->_impl_.netguid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnrealObjectRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[2]);
}

// ===================================================================

class ActorComponentRef::_Internal {
 public:
  using HasBits = decltype(std::declval<ActorComponentRef>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& owner(const ActorComponentRef* msg);
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_compname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
ActorComponentRef::_Internal::owner(const ActorComponentRef* msg) {
  return *msg->_impl_.owner_;
}
ActorComponentRef::ActorComponentRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ActorComponentRef)
}
ActorComponentRef::ActorComponentRef(const ActorComponentRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActorComponentRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compname_){}
    , decltype(_impl_.owner_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.compname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_compname()) {
    _this->_impl_.compname_.Set(from._internal_compname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_owner()) {
    _this->_impl_.owner_ = new ::unrealpb::UnrealObjectRef(*from._impl_.owner_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.ActorComponentRef)
}

inline void ActorComponentRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compname_){}
    , decltype(_impl_.owner_){nullptr}
  };
  _impl_.compname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActorComponentRef::~ActorComponentRef() {
  // @@protoc_insertion_point(destructor:unrealpb.ActorComponentRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActorComponentRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.compname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.owner_;
}

void ActorComponentRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActorComponentRef::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ActorComponentRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.compname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.owner_ != nullptr);
      _impl_.owner_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActorComponentRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.UnrealObjectRef owner = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string compName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_compname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.ActorComponentRef.compName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActorComponentRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ActorComponentRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.UnrealObjectRef owner = 1;
  if (_internal_has_owner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::owner(this),
        _Internal::owner(this).GetCachedSize(), target, stream);
  }

  // optional string compName = 2;
  if (_internal_has_compname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_compname().data(), static_cast<int>(this->_internal_compname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.ActorComponentRef.compName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_compname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ActorComponentRef)
  return target;
}

size_t ActorComponentRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ActorComponentRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string compName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_compname());
    }

    // optional .unrealpb.UnrealObjectRef owner = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActorComponentRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActorComponentRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActorComponentRef::GetClassData() const { return &_class_data_; }


void ActorComponentRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActorComponentRef*>(&to_msg);
  auto& from = static_cast<const ActorComponentRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ActorComponentRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_compname(from._internal_compname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_owner()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_owner());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActorComponentRef::CopyFrom(const ActorComponentRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ActorComponentRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorComponentRef::IsInitialized() const {
  return true;
}

void ActorComponentRef::InternalSwap(ActorComponentRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.compname_, lhs_arena,
      &other->_impl_.compname_, rhs_arena
  );
  swap(_impl_.owner_, other->_impl_.owner_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActorComponentRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[3]);
}

// ===================================================================

class RemoteFunctionMessage::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& targetobj(const RemoteFunctionMessage* msg);
};

const ::unrealpb::UnrealObjectRef&
RemoteFunctionMessage::_Internal::targetobj(const RemoteFunctionMessage* msg) {
  return *msg->_impl_.targetobj_;
}
RemoteFunctionMessage::RemoteFunctionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.RemoteFunctionMessage)
}
RemoteFunctionMessage::RemoteFunctionMessage(const RemoteFunctionMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoteFunctionMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.functionname_){}
    , decltype(_impl_.paramspayload_){}
    , decltype(_impl_.targetobj_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.functionname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.functionname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_functionname().empty()) {
    _this->_impl_.functionname_.Set(from._internal_functionname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.paramspayload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paramspayload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_paramspayload().empty()) {
    _this->_impl_.paramspayload_.Set(from._internal_paramspayload(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_targetobj()) {
    _this->_impl_.targetobj_ = new ::unrealpb::UnrealObjectRef(*from._impl_.targetobj_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.RemoteFunctionMessage)
}

inline void RemoteFunctionMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.functionname_){}
    , decltype(_impl_.paramspayload_){}
    , decltype(_impl_.targetobj_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.functionname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.functionname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.paramspayload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paramspayload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoteFunctionMessage::~RemoteFunctionMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.RemoteFunctionMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoteFunctionMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.functionname_.Destroy();
  _impl_.paramspayload_.Destroy();
  if (this != internal_default_instance()) delete _impl_.targetobj_;
}

void RemoteFunctionMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoteFunctionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.RemoteFunctionMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.functionname_.ClearToEmpty();
  _impl_.paramspayload_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.targetobj_ != nullptr) {
    delete _impl_.targetobj_;
  }
  _impl_.targetobj_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoteFunctionMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef targetObj = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetobj(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string functionName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_functionname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.RemoteFunctionMessage.functionName"));
        } else
          goto handle_unusual;
        continue;
      // bytes paramsPayload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_paramspayload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoteFunctionMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.RemoteFunctionMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef targetObj = 1;
  if (this->_internal_has_targetobj()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::targetobj(this),
        _Internal::targetobj(this).GetCachedSize(), target, stream);
  }

  // string functionName = 2;
  if (!this->_internal_functionname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_functionname().data(), static_cast<int>(this->_internal_functionname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.RemoteFunctionMessage.functionName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_functionname(), target);
  }

  // bytes paramsPayload = 3;
  if (!this->_internal_paramspayload().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_paramspayload(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.RemoteFunctionMessage)
  return target;
}

size_t RemoteFunctionMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.RemoteFunctionMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string functionName = 2;
  if (!this->_internal_functionname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_functionname());
  }

  // bytes paramsPayload = 3;
  if (!this->_internal_paramspayload().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_paramspayload());
  }

  // .unrealpb.UnrealObjectRef targetObj = 1;
  if (this->_internal_has_targetobj()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.targetobj_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoteFunctionMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoteFunctionMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoteFunctionMessage::GetClassData() const { return &_class_data_; }


void RemoteFunctionMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoteFunctionMessage*>(&to_msg);
  auto& from = static_cast<const RemoteFunctionMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.RemoteFunctionMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_functionname().empty()) {
    _this->_internal_set_functionname(from._internal_functionname());
  }
  if (!from._internal_paramspayload().empty()) {
    _this->_internal_set_paramspayload(from._internal_paramspayload());
  }
  if (from._internal_has_targetobj()) {
    _this->_internal_mutable_targetobj()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_targetobj());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoteFunctionMessage::CopyFrom(const RemoteFunctionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.RemoteFunctionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteFunctionMessage::IsInitialized() const {
  return true;
}

void RemoteFunctionMessage::InternalSwap(RemoteFunctionMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.functionname_, lhs_arena,
      &other->_impl_.functionname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.paramspayload_, lhs_arena,
      &other->_impl_.paramspayload_, rhs_arena
  );
  swap(_impl_.targetobj_, other->_impl_.targetobj_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoteFunctionMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[4]);
}

// ===================================================================

class SpawnObjectMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SpawnObjectMessage>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& obj(const SpawnObjectMessage* msg);
  static void set_has_localrole(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
SpawnObjectMessage::_Internal::obj(const SpawnObjectMessage* msg) {
  return *msg->_impl_.obj_;
}
SpawnObjectMessage::SpawnObjectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.SpawnObjectMessage)
}
SpawnObjectMessage::SpawnObjectMessage(const SpawnObjectMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpawnObjectMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obj_){nullptr}
    , decltype(_impl_.localrole_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_obj()) {
    _this->_impl_.obj_ = new ::unrealpb::UnrealObjectRef(*from._impl_.obj_);
  }
  _this->_impl_.localrole_ = from._impl_.localrole_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.SpawnObjectMessage)
}

inline void SpawnObjectMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obj_){nullptr}
    , decltype(_impl_.localrole_){0u}
  };
}

SpawnObjectMessage::~SpawnObjectMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.SpawnObjectMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpawnObjectMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.obj_;
}

void SpawnObjectMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpawnObjectMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.SpawnObjectMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.obj_ != nullptr) {
    delete _impl_.obj_;
  }
  _impl_.obj_ = nullptr;
  _impl_.localrole_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpawnObjectMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef obj = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_obj(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 localRole = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_localrole(&has_bits);
          _impl_.localrole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpawnObjectMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.SpawnObjectMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef obj = 1;
  if (this->_internal_has_obj()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::obj(this),
        _Internal::obj(this).GetCachedSize(), target, stream);
  }

  // optional uint32 localRole = 2;
  if (_internal_has_localrole()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_localrole(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.SpawnObjectMessage)
  return target;
}

size_t SpawnObjectMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.SpawnObjectMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef obj = 1;
  if (this->_internal_has_obj()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.obj_);
  }

  // optional uint32 localRole = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_localrole());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpawnObjectMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpawnObjectMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpawnObjectMessage::GetClassData() const { return &_class_data_; }


void SpawnObjectMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpawnObjectMessage*>(&to_msg);
  auto& from = static_cast<const SpawnObjectMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.SpawnObjectMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obj()) {
    _this->_internal_mutable_obj()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_obj());
  }
  if (from._internal_has_localrole()) {
    _this->_internal_set_localrole(from._internal_localrole());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpawnObjectMessage::CopyFrom(const SpawnObjectMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.SpawnObjectMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpawnObjectMessage::IsInitialized() const {
  return true;
}

void SpawnObjectMessage::InternalSwap(SpawnObjectMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpawnObjectMessage, _impl_.localrole_)
      + sizeof(SpawnObjectMessage::_impl_.localrole_)
      - PROTOBUF_FIELD_OFFSET(SpawnObjectMessage, _impl_.obj_)>(
          reinterpret_cast<char*>(&_impl_.obj_),
          reinterpret_cast<char*>(&other->_impl_.obj_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpawnObjectMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[5]);
}

// ===================================================================

class ActorState::_Internal {
 public:
  using HasBits = decltype(std::declval<ActorState>()._impl_._has_bits_);
  static void set_has_owningconnid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_breplicatemovement(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_localrole(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remoterole(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::unrealpb::UnrealObjectRef& owner(const ActorState* msg);
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bhidden(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_btearoff(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_bcanbedamaged(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::unrealpb::UnrealObjectRef& instigator(const ActorState* msg);
  static void set_has_instigator(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::unrealpb::UnrealObjectRef&
ActorState::_Internal::owner(const ActorState* msg) {
  return *msg->_impl_.owner_;
}
const ::unrealpb::UnrealObjectRef&
ActorState::_Internal::instigator(const ActorState* msg) {
  return *msg->_impl_.instigator_;
}
ActorState::ActorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ActorState)
}
ActorState::ActorState(const ActorState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActorState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_){nullptr}
    , decltype(_impl_.instigator_){nullptr}
    , decltype(_impl_.owningconnid_){}
    , decltype(_impl_.localrole_){}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.breplicatemovement_){}
    , decltype(_impl_.bhidden_){}
    , decltype(_impl_.btearoff_){}
    , decltype(_impl_.remoterole_){}
    , decltype(_impl_.bcanbedamaged_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner()) {
    _this->_impl_.owner_ = new ::unrealpb::UnrealObjectRef(*from._impl_.owner_);
  }
  if (from._internal_has_instigator()) {
    _this->_impl_.instigator_ = new ::unrealpb::UnrealObjectRef(*from._impl_.instigator_);
  }
  ::memcpy(&_impl_.owningconnid_, &from._impl_.owningconnid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bcanbedamaged_) -
    reinterpret_cast<char*>(&_impl_.owningconnid_)) + sizeof(_impl_.bcanbedamaged_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.ActorState)
}

inline void ActorState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_){nullptr}
    , decltype(_impl_.instigator_){nullptr}
    , decltype(_impl_.owningconnid_){0u}
    , decltype(_impl_.localrole_){0u}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.breplicatemovement_){false}
    , decltype(_impl_.bhidden_){false}
    , decltype(_impl_.btearoff_){false}
    , decltype(_impl_.remoterole_){0u}
    , decltype(_impl_.bcanbedamaged_){false}
  };
}

ActorState::~ActorState() {
  // @@protoc_insertion_point(destructor:unrealpb.ActorState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActorState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_;
  if (this != internal_default_instance()) delete _impl_.instigator_;
}

void ActorState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActorState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ActorState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.owner_ != nullptr);
      _impl_.owner_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instigator_ != nullptr);
      _impl_.instigator_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.owningconnid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.localrole_) -
        reinterpret_cast<char*>(&_impl_.owningconnid_)) + sizeof(_impl_.localrole_));
  }
  _impl_.removed_ = false;
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.breplicatemovement_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.remoterole_) -
        reinterpret_cast<char*>(&_impl_.breplicatemovement_)) + sizeof(_impl_.remoterole_));
  }
  _impl_.bcanbedamaged_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActorState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 owningConnId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_owningconnid(&has_bits);
          _impl_.owningconnid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bReplicateMovement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_breplicatemovement(&has_bits);
          _impl_.breplicatemovement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 localRole = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_localrole(&has_bits);
          _impl_.localrole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 remoteRole = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_remoterole(&has_bits);
          _impl_.remoterole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef owner = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bHidden = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bhidden(&has_bits);
          _impl_.bhidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bTearOff = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_btearoff(&has_bits);
          _impl_.btearoff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bCanBeDamaged = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bcanbedamaged(&has_bits);
          _impl_.bcanbedamaged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef instigator = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_instigator(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActorState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ActorState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional uint32 owningConnId = 2;
  if (_internal_has_owningconnid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_owningconnid(), target);
  }

  // optional bool bReplicateMovement = 3;
  if (_internal_has_breplicatemovement()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_breplicatemovement(), target);
  }

  // optional uint32 localRole = 4;
  if (_internal_has_localrole()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_localrole(), target);
  }

  // optional uint32 remoteRole = 5;
  if (_internal_has_remoterole()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_remoterole(), target);
  }

  // optional .unrealpb.UnrealObjectRef owner = 6;
  if (_internal_has_owner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::owner(this),
        _Internal::owner(this).GetCachedSize(), target, stream);
  }

  // optional bool bHidden = 7;
  if (_internal_has_bhidden()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bhidden(), target);
  }

  // optional bool bTearOff = 8;
  if (_internal_has_btearoff()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_btearoff(), target);
  }

  // optional bool bCanBeDamaged = 9;
  if (_internal_has_bcanbedamaged()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_bcanbedamaged(), target);
  }

  // optional .unrealpb.UnrealObjectRef instigator = 10;
  if (_internal_has_instigator()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::instigator(this),
        _Internal::instigator(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ActorState)
  return target;
}

size_t ActorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ActorState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .unrealpb.UnrealObjectRef owner = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_);
    }

    // optional .unrealpb.UnrealObjectRef instigator = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instigator_);
    }

    // optional uint32 owningConnId = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owningconnid());
    }

    // optional uint32 localRole = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_localrole());
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x000000f0u) {
    // optional bool bReplicateMovement = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool bHidden = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool bTearOff = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 remoteRole = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remoterole());
    }

  }
  // optional bool bCanBeDamaged = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActorState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActorState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActorState::GetClassData() const { return &_class_data_; }


void ActorState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActorState*>(&to_msg);
  auto& from = static_cast<const ActorState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ActorState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_owner());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instigator()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_instigator());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.owningconnid_ = from._impl_.owningconnid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.localrole_ = from._impl_.localrole_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  if (cached_has_bits & 0x000000f0u) {
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.breplicatemovement_ = from._impl_.breplicatemovement_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.bhidden_ = from._impl_.bhidden_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.btearoff_ = from._impl_.btearoff_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.remoterole_ = from._impl_.remoterole_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_bcanbedamaged(from._internal_bcanbedamaged());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActorState::CopyFrom(const ActorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ActorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorState::IsInitialized() const {
  return true;
}

void ActorState::InternalSwap(ActorState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActorState, _impl_.bcanbedamaged_)
      + sizeof(ActorState::_impl_.bcanbedamaged_)
      - PROTOBUF_FIELD_OFFSET(ActorState, _impl_.owner_)>(
          reinterpret_cast<char*>(&_impl_.owner_),
          reinterpret_cast<char*>(&other->_impl_.owner_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActorState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[6]);
}

// ===================================================================

class ActorComponentState::_Internal {
 public:
  using HasBits = decltype(std::declval<ActorComponentState>()._impl_._has_bits_);
  static void set_has_bisactive(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_breplicated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ActorComponentState::ActorComponentState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ActorComponentState)
}
ActorComponentState::ActorComponentState(const ActorComponentState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActorComponentState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bisactive_){}
    , decltype(_impl_.breplicated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.bisactive_, &from._impl_.bisactive_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.breplicated_) -
    reinterpret_cast<char*>(&_impl_.bisactive_)) + sizeof(_impl_.breplicated_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.ActorComponentState)
}

inline void ActorComponentState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bisactive_){false}
    , decltype(_impl_.breplicated_){false}
  };
}

ActorComponentState::~ActorComponentState() {
  // @@protoc_insertion_point(destructor:unrealpb.ActorComponentState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActorComponentState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActorComponentState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActorComponentState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ActorComponentState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.bisactive_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.breplicated_) -
      reinterpret_cast<char*>(&_impl_.bisactive_)) + sizeof(_impl_.breplicated_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActorComponentState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool bIsActive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bisactive(&has_bits);
          _impl_.bisactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bReplicated = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_breplicated(&has_bits);
          _impl_.breplicated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActorComponentState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ActorComponentState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool bIsActive = 1;
  if (_internal_has_bisactive()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_bisactive(), target);
  }

  // optional bool bReplicated = 2;
  if (_internal_has_breplicated()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_breplicated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ActorComponentState)
  return target;
}

size_t ActorComponentState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ActorComponentState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool bIsActive = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool bReplicated = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActorComponentState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActorComponentState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActorComponentState::GetClassData() const { return &_class_data_; }


void ActorComponentState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActorComponentState*>(&to_msg);
  auto& from = static_cast<const ActorComponentState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ActorComponentState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bisactive_ = from._impl_.bisactive_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.breplicated_ = from._impl_.breplicated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActorComponentState::CopyFrom(const ActorComponentState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ActorComponentState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorComponentState::IsInitialized() const {
  return true;
}

void ActorComponentState::InternalSwap(ActorComponentState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActorComponentState, _impl_.breplicated_)
      + sizeof(ActorComponentState::_impl_.breplicated_)
      - PROTOBUF_FIELD_OFFSET(ActorComponentState, _impl_.bisactive_)>(
          reinterpret_cast<char*>(&_impl_.bisactive_),
          reinterpret_cast<char*>(&other->_impl_.bisactive_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActorComponentState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[7]);
}

// ===================================================================

class SceneComponentState::_Internal {
 public:
  using HasBits = decltype(std::declval<SceneComponentState>()._impl_._has_bits_);
  static void set_has_babsolutelocation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_babsoluterotation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_babsolutescale(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bvisible(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_bshouldbeattached(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_bshouldsnaplocationwhenattached(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_bshouldsnaprotationwhenattached(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::unrealpb::UnrealObjectRef& attachparent(const SceneComponentState* msg);
  static void set_has_attachparent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attachsocketname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& relativelocation(const SceneComponentState* msg);
  static void set_has_relativelocation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& relativerotation(const SceneComponentState* msg);
  static void set_has_relativerotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::unrealpb::FVector& relativescale(const SceneComponentState* msg);
  static void set_has_relativescale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::unrealpb::UnrealObjectRef&
SceneComponentState::_Internal::attachparent(const SceneComponentState* msg) {
  return *msg->_impl_.attachparent_;
}
const ::unrealpb::FVector&
SceneComponentState::_Internal::relativelocation(const SceneComponentState* msg) {
  return *msg->_impl_.relativelocation_;
}
const ::unrealpb::FVector&
SceneComponentState::_Internal::relativerotation(const SceneComponentState* msg) {
  return *msg->_impl_.relativerotation_;
}
const ::unrealpb::FVector&
SceneComponentState::_Internal::relativescale(const SceneComponentState* msg) {
  return *msg->_impl_.relativescale_;
}
SceneComponentState::SceneComponentState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.SceneComponentState)
}
SceneComponentState::SceneComponentState(const SceneComponentState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SceneComponentState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachchildren_){from._impl_.attachchildren_}
    , decltype(_impl_.attachsocketname_){}
    , decltype(_impl_.attachparent_){nullptr}
    , decltype(_impl_.relativelocation_){nullptr}
    , decltype(_impl_.relativerotation_){nullptr}
    , decltype(_impl_.relativescale_){nullptr}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.babsolutelocation_){}
    , decltype(_impl_.babsoluterotation_){}
    , decltype(_impl_.babsolutescale_){}
    , decltype(_impl_.bvisible_){}
    , decltype(_impl_.bshouldbeattached_){}
    , decltype(_impl_.bshouldsnaplocationwhenattached_){}
    , decltype(_impl_.bshouldsnaprotationwhenattached_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.attachsocketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachsocketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attachsocketname()) {
    _this->_impl_.attachsocketname_.Set(from._internal_attachsocketname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_attachparent()) {
    _this->_impl_.attachparent_ = new ::unrealpb::UnrealObjectRef(*from._impl_.attachparent_);
  }
  if (from._internal_has_relativelocation()) {
    _this->_impl_.relativelocation_ = new ::unrealpb::FVector(*from._impl_.relativelocation_);
  }
  if (from._internal_has_relativerotation()) {
    _this->_impl_.relativerotation_ = new ::unrealpb::FVector(*from._impl_.relativerotation_);
  }
  if (from._internal_has_relativescale()) {
    _this->_impl_.relativescale_ = new ::unrealpb::FVector(*from._impl_.relativescale_);
  }
  ::memcpy(&_impl_.removed_, &from._impl_.removed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bshouldsnaprotationwhenattached_) -
    reinterpret_cast<char*>(&_impl_.removed_)) + sizeof(_impl_.bshouldsnaprotationwhenattached_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.SceneComponentState)
}

inline void SceneComponentState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachchildren_){arena}
    , decltype(_impl_.attachsocketname_){}
    , decltype(_impl_.attachparent_){nullptr}
    , decltype(_impl_.relativelocation_){nullptr}
    , decltype(_impl_.relativerotation_){nullptr}
    , decltype(_impl_.relativescale_){nullptr}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.babsolutelocation_){false}
    , decltype(_impl_.babsoluterotation_){false}
    , decltype(_impl_.babsolutescale_){false}
    , decltype(_impl_.bvisible_){false}
    , decltype(_impl_.bshouldbeattached_){false}
    , decltype(_impl_.bshouldsnaplocationwhenattached_){false}
    , decltype(_impl_.bshouldsnaprotationwhenattached_){false}
  };
  _impl_.attachsocketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachsocketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SceneComponentState::~SceneComponentState() {
  // @@protoc_insertion_point(destructor:unrealpb.SceneComponentState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SceneComponentState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachchildren_.~RepeatedPtrField();
  _impl_.attachsocketname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.attachparent_;
  if (this != internal_default_instance()) delete _impl_.relativelocation_;
  if (this != internal_default_instance()) delete _impl_.relativerotation_;
  if (this != internal_default_instance()) delete _impl_.relativescale_;
}

void SceneComponentState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SceneComponentState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.SceneComponentState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachchildren_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.attachsocketname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.attachparent_ != nullptr);
      _impl_.attachparent_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.relativelocation_ != nullptr);
      _impl_.relativelocation_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.relativerotation_ != nullptr);
      _impl_.relativerotation_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.relativescale_ != nullptr);
      _impl_.relativescale_->Clear();
    }
  }
  _impl_.removed_ = false;
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.babsolutelocation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.babsolutescale_) -
        reinterpret_cast<char*>(&_impl_.babsolutelocation_)) + sizeof(_impl_.babsolutescale_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.bvisible_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bshouldsnaprotationwhenattached_) -
        reinterpret_cast<char*>(&_impl_.bvisible_)) + sizeof(_impl_.bshouldsnaprotationwhenattached_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SceneComponentState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bAbsoluteLocation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_babsolutelocation(&has_bits);
          _impl_.babsolutelocation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bAbsoluteRotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_babsoluterotation(&has_bits);
          _impl_.babsoluterotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bAbsoluteScale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_babsolutescale(&has_bits);
          _impl_.babsolutescale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bVisible = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bvisible(&has_bits);
          _impl_.bvisible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bShouldBeAttached = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_bshouldbeattached(&has_bits);
          _impl_.bshouldbeattached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bShouldSnapLocationWhenAttached = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bshouldsnaplocationwhenattached(&has_bits);
          _impl_.bshouldsnaplocationwhenattached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bShouldSnapRotationWhenAttached = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_bshouldsnaprotationwhenattached(&has_bits);
          _impl_.bshouldsnaprotationwhenattached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef attachParent = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachparent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unrealpb.UnrealObjectRef attachChildren = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attachchildren(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string attachSocketName = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_attachsocketname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.SceneComponentState.attachSocketName"));
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeLocation = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativelocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeRotation = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativerotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeScale = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativescale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SceneComponentState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.SceneComponentState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional bool bAbsoluteLocation = 2;
  if (_internal_has_babsolutelocation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_babsolutelocation(), target);
  }

  // optional bool bAbsoluteRotation = 3;
  if (_internal_has_babsoluterotation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_babsoluterotation(), target);
  }

  // optional bool bAbsoluteScale = 4;
  if (_internal_has_babsolutescale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_babsolutescale(), target);
  }

  // optional bool bVisible = 5;
  if (_internal_has_bvisible()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bvisible(), target);
  }

  // optional bool bShouldBeAttached = 6;
  if (_internal_has_bshouldbeattached()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_bshouldbeattached(), target);
  }

  // optional bool bShouldSnapLocationWhenAttached = 7;
  if (_internal_has_bshouldsnaplocationwhenattached()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bshouldsnaplocationwhenattached(), target);
  }

  // optional bool bShouldSnapRotationWhenAttached = 8;
  if (_internal_has_bshouldsnaprotationwhenattached()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_bshouldsnaprotationwhenattached(), target);
  }

  // optional .unrealpb.UnrealObjectRef attachParent = 9;
  if (_internal_has_attachparent()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::attachparent(this),
        _Internal::attachparent(this).GetCachedSize(), target, stream);
  }

  // repeated .unrealpb.UnrealObjectRef attachChildren = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attachchildren_size()); i < n; i++) {
    const auto& repfield = this->_internal_attachchildren(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string attachSocketName = 11;
  if (_internal_has_attachsocketname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_attachsocketname().data(), static_cast<int>(this->_internal_attachsocketname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.SceneComponentState.attachSocketName");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_attachsocketname(), target);
  }

  // optional .unrealpb.FVector relativeLocation = 12;
  if (_internal_has_relativelocation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::relativelocation(this),
        _Internal::relativelocation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector relativeRotation = 13;
  if (_internal_has_relativerotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::relativerotation(this),
        _Internal::relativerotation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector relativeScale = 14;
  if (_internal_has_relativescale()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::relativescale(this),
        _Internal::relativescale(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.SceneComponentState)
  return target;
}

size_t SceneComponentState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.SceneComponentState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.UnrealObjectRef attachChildren = 10;
  total_size += 1UL * this->_internal_attachchildren_size();
  for (const auto& msg : this->_impl_.attachchildren_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string attachSocketName = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_attachsocketname());
    }

    // optional .unrealpb.UnrealObjectRef attachParent = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachparent_);
    }

    // optional .unrealpb.FVector relativeLocation = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativelocation_);
    }

    // optional .unrealpb.FVector relativeRotation = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativerotation_);
    }

    // optional .unrealpb.FVector relativeScale = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativescale_);
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x000000e0u) {
    // optional bool bAbsoluteLocation = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool bAbsoluteRotation = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool bAbsoluteScale = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool bVisible = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool bShouldBeAttached = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool bShouldSnapLocationWhenAttached = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool bShouldSnapRotationWhenAttached = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SceneComponentState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SceneComponentState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SceneComponentState::GetClassData() const { return &_class_data_; }


void SceneComponentState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SceneComponentState*>(&to_msg);
  auto& from = static_cast<const SceneComponentState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.SceneComponentState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attachchildren_.MergeFrom(from._impl_.attachchildren_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attachsocketname(from._internal_attachsocketname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_attachparent()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_attachparent());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_relativelocation()->::unrealpb::FVector::MergeFrom(
          from._internal_relativelocation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_relativerotation()->::unrealpb::FVector::MergeFrom(
          from._internal_relativerotation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_relativescale()->::unrealpb::FVector::MergeFrom(
          from._internal_relativescale());
    }
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  if (cached_has_bits & 0x000000e0u) {
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.babsolutelocation_ = from._impl_.babsolutelocation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.babsoluterotation_ = from._impl_.babsoluterotation_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.babsolutescale_ = from._impl_.babsolutescale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.bvisible_ = from._impl_.bvisible_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bshouldbeattached_ = from._impl_.bshouldbeattached_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.bshouldsnaplocationwhenattached_ = from._impl_.bshouldsnaplocationwhenattached_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.bshouldsnaprotationwhenattached_ = from._impl_.bshouldsnaprotationwhenattached_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SceneComponentState::CopyFrom(const SceneComponentState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.SceneComponentState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SceneComponentState::IsInitialized() const {
  return true;
}

void SceneComponentState::InternalSwap(SceneComponentState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attachchildren_.InternalSwap(&other->_impl_.attachchildren_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attachsocketname_, lhs_arena,
      &other->_impl_.attachsocketname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SceneComponentState, _impl_.bshouldsnaprotationwhenattached_)
      + sizeof(SceneComponentState::_impl_.bshouldsnaprotationwhenattached_)
      - PROTOBUF_FIELD_OFFSET(SceneComponentState, _impl_.attachparent_)>(
          reinterpret_cast<char*>(&_impl_.attachparent_),
          reinterpret_cast<char*>(&other->_impl_.attachparent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SceneComponentState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[8]);
}

// ===================================================================

class RootMotionMontage::_Internal {
 public:
};

RootMotionMontage::RootMotionMontage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:unrealpb.RootMotionMontage)
}
RootMotionMontage::RootMotionMontage(const RootMotionMontage& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  RootMotionMontage* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:unrealpb.RootMotionMontage)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RootMotionMontage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RootMotionMontage::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RootMotionMontage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[9]);
}

// ===================================================================

class BasedMovementInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BasedMovementInfo>()._impl_._has_bits_);
  static const ::unrealpb::ActorComponentRef& movementbase(const BasedMovementInfo* msg);
  static void set_has_movementbase(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& location(const BasedMovementInfo* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& rotation(const BasedMovementInfo* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bserverhasbasecomponent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_brelativerotation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_bserverhasvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::unrealpb::ActorComponentRef&
BasedMovementInfo::_Internal::movementbase(const BasedMovementInfo* msg) {
  return *msg->_impl_.movementbase_;
}
const ::unrealpb::FVector&
BasedMovementInfo::_Internal::location(const BasedMovementInfo* msg) {
  return *msg->_impl_.location_;
}
const ::unrealpb::FVector&
BasedMovementInfo::_Internal::rotation(const BasedMovementInfo* msg) {
  return *msg->_impl_.rotation_;
}
BasedMovementInfo::BasedMovementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.BasedMovementInfo)
}
BasedMovementInfo::BasedMovementInfo(const BasedMovementInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BasedMovementInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonename_){}
    , decltype(_impl_.movementbase_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.bserverhasbasecomponent_){}
    , decltype(_impl_.brelativerotation_){}
    , decltype(_impl_.bserverhasvelocity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.bonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bonename()) {
    _this->_impl_.bonename_.Set(from._internal_bonename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_movementbase()) {
    _this->_impl_.movementbase_ = new ::unrealpb::ActorComponentRef(*from._impl_.movementbase_);
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::unrealpb::FVector(*from._impl_.location_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::unrealpb::FVector(*from._impl_.rotation_);
  }
  ::memcpy(&_impl_.bserverhasbasecomponent_, &from._impl_.bserverhasbasecomponent_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bserverhasvelocity_) -
    reinterpret_cast<char*>(&_impl_.bserverhasbasecomponent_)) + sizeof(_impl_.bserverhasvelocity_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.BasedMovementInfo)
}

inline void BasedMovementInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonename_){}
    , decltype(_impl_.movementbase_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.bserverhasbasecomponent_){false}
    , decltype(_impl_.brelativerotation_){false}
    , decltype(_impl_.bserverhasvelocity_){false}
  };
  _impl_.bonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BasedMovementInfo::~BasedMovementInfo() {
  // @@protoc_insertion_point(destructor:unrealpb.BasedMovementInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BasedMovementInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bonename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.movementbase_;
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void BasedMovementInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BasedMovementInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.BasedMovementInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.bonename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.movementbase_ != nullptr);
      _impl_.movementbase_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  ::memset(&_impl_.bserverhasbasecomponent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bserverhasvelocity_) -
      reinterpret_cast<char*>(&_impl_.bserverhasbasecomponent_)) + sizeof(_impl_.bserverhasvelocity_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BasedMovementInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.ActorComponentRef movementBase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_movementbase(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string boneName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bonename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.BasedMovementInfo.boneName"));
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bServerHasBaseComponent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bserverhasbasecomponent(&has_bits);
          _impl_.bserverhasbasecomponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bRelativeRotation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_brelativerotation(&has_bits);
          _impl_.brelativerotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bServerHasVelocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bserverhasvelocity(&has_bits);
          _impl_.bserverhasvelocity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BasedMovementInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.BasedMovementInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.ActorComponentRef movementBase = 1;
  if (_internal_has_movementbase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::movementbase(this),
        _Internal::movementbase(this).GetCachedSize(), target, stream);
  }

  // optional string boneName = 2;
  if (_internal_has_bonename()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bonename().data(), static_cast<int>(this->_internal_bonename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.BasedMovementInfo.boneName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bonename(), target);
  }

  // optional .unrealpb.FVector location = 3;
  if (_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector rotation = 4;
  if (_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // optional bool bServerHasBaseComponent = 5;
  if (_internal_has_bserverhasbasecomponent()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bserverhasbasecomponent(), target);
  }

  // optional bool bRelativeRotation = 6;
  if (_internal_has_brelativerotation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_brelativerotation(), target);
  }

  // optional bool bServerHasVelocity = 7;
  if (_internal_has_bserverhasvelocity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bserverhasvelocity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.BasedMovementInfo)
  return target;
}

size_t BasedMovementInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.BasedMovementInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string boneName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bonename());
    }

    // optional .unrealpb.ActorComponentRef movementBase = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.movementbase_);
    }

    // optional .unrealpb.FVector location = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional .unrealpb.FVector rotation = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

    // optional bool bServerHasBaseComponent = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool bRelativeRotation = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool bServerHasVelocity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasedMovementInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BasedMovementInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasedMovementInfo::GetClassData() const { return &_class_data_; }


void BasedMovementInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BasedMovementInfo*>(&to_msg);
  auto& from = static_cast<const BasedMovementInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.BasedMovementInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_bonename(from._internal_bonename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_movementbase()->::unrealpb::ActorComponentRef::MergeFrom(
          from._internal_movementbase());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_location()->::unrealpb::FVector::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rotation()->::unrealpb::FVector::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bserverhasbasecomponent_ = from._impl_.bserverhasbasecomponent_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.brelativerotation_ = from._impl_.brelativerotation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.bserverhasvelocity_ = from._impl_.bserverhasvelocity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BasedMovementInfo::CopyFrom(const BasedMovementInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.BasedMovementInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasedMovementInfo::IsInitialized() const {
  return true;
}

void BasedMovementInfo::InternalSwap(BasedMovementInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bonename_, lhs_arena,
      &other->_impl_.bonename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasedMovementInfo, _impl_.bserverhasvelocity_)
      + sizeof(BasedMovementInfo::_impl_.bserverhasvelocity_)
      - PROTOBUF_FIELD_OFFSET(BasedMovementInfo, _impl_.movementbase_)>(
          reinterpret_cast<char*>(&_impl_.movementbase_),
          reinterpret_cast<char*>(&other->_impl_.movementbase_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BasedMovementInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[10]);
}

// ===================================================================

class CharacterState::_Internal {
 public:
  using HasBits = decltype(std::declval<CharacterState>()._impl_._has_bits_);
  static const ::unrealpb::RootMotionMontage& rootmotion(const CharacterState* msg);
  static void set_has_rootmotion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::BasedMovementInfo& basedmovement(const CharacterState* msg);
  static void set_has_basedmovement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serverlasttransformupdatetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_movementmode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_biscrouched(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bproxyisjumpforceapplied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_animrootmotiontranslationscale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_replaylasttransformupdatetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::unrealpb::RootMotionMontage&
CharacterState::_Internal::rootmotion(const CharacterState* msg) {
  return *msg->_impl_.rootmotion_;
}
const ::unrealpb::BasedMovementInfo&
CharacterState::_Internal::basedmovement(const CharacterState* msg) {
  return *msg->_impl_.basedmovement_;
}
CharacterState::CharacterState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.CharacterState)
}
CharacterState::CharacterState(const CharacterState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CharacterState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rootmotion_){nullptr}
    , decltype(_impl_.basedmovement_){nullptr}
    , decltype(_impl_.serverlasttransformupdatetimestamp_){}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.biscrouched_){}
    , decltype(_impl_.bproxyisjumpforceapplied_){}
    , decltype(_impl_.movementmode_){}
    , decltype(_impl_.animrootmotiontranslationscale_){}
    , decltype(_impl_.replaylasttransformupdatetimestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rootmotion()) {
    _this->_impl_.rootmotion_ = new ::unrealpb::RootMotionMontage(*from._impl_.rootmotion_);
  }
  if (from._internal_has_basedmovement()) {
    _this->_impl_.basedmovement_ = new ::unrealpb::BasedMovementInfo(*from._impl_.basedmovement_);
  }
  ::memcpy(&_impl_.serverlasttransformupdatetimestamp_, &from._impl_.serverlasttransformupdatetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.replaylasttransformupdatetimestamp_) -
    reinterpret_cast<char*>(&_impl_.serverlasttransformupdatetimestamp_)) + sizeof(_impl_.replaylasttransformupdatetimestamp_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.CharacterState)
}

inline void CharacterState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rootmotion_){nullptr}
    , decltype(_impl_.basedmovement_){nullptr}
    , decltype(_impl_.serverlasttransformupdatetimestamp_){0}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.biscrouched_){false}
    , decltype(_impl_.bproxyisjumpforceapplied_){false}
    , decltype(_impl_.movementmode_){0u}
    , decltype(_impl_.animrootmotiontranslationscale_){0}
    , decltype(_impl_.replaylasttransformupdatetimestamp_){0}
  };
}

CharacterState::~CharacterState() {
  // @@protoc_insertion_point(destructor:unrealpb.CharacterState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CharacterState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rootmotion_;
  if (this != internal_default_instance()) delete _impl_.basedmovement_;
}

void CharacterState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CharacterState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.CharacterState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.rootmotion_ != nullptr);
      _impl_.rootmotion_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.basedmovement_ != nullptr);
      _impl_.basedmovement_->Clear();
    }
  }
  _impl_.serverlasttransformupdatetimestamp_ = 0;
  _impl_.removed_ = false;
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.biscrouched_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.replaylasttransformupdatetimestamp_) -
        reinterpret_cast<char*>(&_impl_.biscrouched_)) + sizeof(_impl_.replaylasttransformupdatetimestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CharacterState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.RootMotionMontage rootMotion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rootmotion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.BasedMovementInfo basedMovement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_basedmovement(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float serverLastTransformUpdateTimeStamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_serverlasttransformupdatetimestamp(&has_bits);
          _impl_.serverlasttransformupdatetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 movementMode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_movementmode(&has_bits);
          _impl_.movementmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bIsCrouched = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_biscrouched(&has_bits);
          _impl_.biscrouched_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bProxyIsJumpForceApplied = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bproxyisjumpforceapplied(&has_bits);
          _impl_.bproxyisjumpforceapplied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float animRootMotionTranslationScale = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_animrootmotiontranslationscale(&has_bits);
          _impl_.animrootmotiontranslationscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float replayLastTransformUpdateTimeStamp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_replaylasttransformupdatetimestamp(&has_bits);
          _impl_.replaylasttransformupdatetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CharacterState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.CharacterState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional .unrealpb.RootMotionMontage rootMotion = 2;
  if (_internal_has_rootmotion()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rootmotion(this),
        _Internal::rootmotion(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.BasedMovementInfo basedMovement = 3;
  if (_internal_has_basedmovement()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::basedmovement(this),
        _Internal::basedmovement(this).GetCachedSize(), target, stream);
  }

  // optional float serverLastTransformUpdateTimeStamp = 4;
  if (_internal_has_serverlasttransformupdatetimestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_serverlasttransformupdatetimestamp(), target);
  }

  // optional uint32 movementMode = 5;
  if (_internal_has_movementmode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_movementmode(), target);
  }

  // optional bool bIsCrouched = 6;
  if (_internal_has_biscrouched()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_biscrouched(), target);
  }

  // optional bool bProxyIsJumpForceApplied = 7;
  if (_internal_has_bproxyisjumpforceapplied()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bproxyisjumpforceapplied(), target);
  }

  // optional float animRootMotionTranslationScale = 8;
  if (_internal_has_animrootmotiontranslationscale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_animrootmotiontranslationscale(), target);
  }

  // optional float replayLastTransformUpdateTimeStamp = 9;
  if (_internal_has_replaylasttransformupdatetimestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_replaylasttransformupdatetimestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.CharacterState)
  return target;
}

size_t CharacterState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.CharacterState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .unrealpb.RootMotionMontage rootMotion = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rootmotion_);
    }

    // optional .unrealpb.BasedMovementInfo basedMovement = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.basedmovement_);
    }

    // optional float serverLastTransformUpdateTimeStamp = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x000000f8u) {
    // optional bool bIsCrouched = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool bProxyIsJumpForceApplied = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 movementMode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_movementmode());
    }

    // optional float animRootMotionTranslationScale = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float replayLastTransformUpdateTimeStamp = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CharacterState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CharacterState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CharacterState::GetClassData() const { return &_class_data_; }


void CharacterState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CharacterState*>(&to_msg);
  auto& from = static_cast<const CharacterState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.CharacterState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rootmotion()->::unrealpb::RootMotionMontage::MergeFrom(
          from._internal_rootmotion());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_basedmovement()->::unrealpb::BasedMovementInfo::MergeFrom(
          from._internal_basedmovement());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.serverlasttransformupdatetimestamp_ = from._impl_.serverlasttransformupdatetimestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  if (cached_has_bits & 0x000000f8u) {
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.biscrouched_ = from._impl_.biscrouched_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bproxyisjumpforceapplied_ = from._impl_.bproxyisjumpforceapplied_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.movementmode_ = from._impl_.movementmode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.animrootmotiontranslationscale_ = from._impl_.animrootmotiontranslationscale_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.replaylasttransformupdatetimestamp_ = from._impl_.replaylasttransformupdatetimestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CharacterState::CopyFrom(const CharacterState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.CharacterState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CharacterState::IsInitialized() const {
  return true;
}

void CharacterState::InternalSwap(CharacterState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CharacterState, _impl_.replaylasttransformupdatetimestamp_)
      + sizeof(CharacterState::_impl_.replaylasttransformupdatetimestamp_)
      - PROTOBUF_FIELD_OFFSET(CharacterState, _impl_.rootmotion_)>(
          reinterpret_cast<char*>(&_impl_.rootmotion_),
          reinterpret_cast<char*>(&other->_impl_.rootmotion_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CharacterState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[11]);
}

// ===================================================================

class Character_ServerMovePacked_Params::_Internal {
 public:
};

Character_ServerMovePacked_Params::Character_ServerMovePacked_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Character_ServerMovePacked_Params)
}
Character_ServerMovePacked_Params::Character_ServerMovePacked_Params(const Character_ServerMovePacked_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Character_ServerMovePacked_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_packedbits().empty()) {
    _this->_impl_.packedbits_.Set(from._internal_packedbits(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.bitsnum_ = from._impl_.bitsnum_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.Character_ServerMovePacked_Params)
}

inline void Character_ServerMovePacked_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Character_ServerMovePacked_Params::~Character_ServerMovePacked_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Character_ServerMovePacked_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Character_ServerMovePacked_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packedbits_.Destroy();
}

void Character_ServerMovePacked_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Character_ServerMovePacked_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Character_ServerMovePacked_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packedbits_.ClearToEmpty();
  _impl_.bitsnum_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Character_ServerMovePacked_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 bitsNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.bitsnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes packedBits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_packedbits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Character_ServerMovePacked_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Character_ServerMovePacked_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bitsnum(), target);
  }

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_packedbits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Character_ServerMovePacked_Params)
  return target;
}

size_t Character_ServerMovePacked_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Character_ServerMovePacked_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_packedbits());
  }

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitsnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Character_ServerMovePacked_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Character_ServerMovePacked_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Character_ServerMovePacked_Params::GetClassData() const { return &_class_data_; }


void Character_ServerMovePacked_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Character_ServerMovePacked_Params*>(&to_msg);
  auto& from = static_cast<const Character_ServerMovePacked_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Character_ServerMovePacked_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_packedbits().empty()) {
    _this->_internal_set_packedbits(from._internal_packedbits());
  }
  if (from._internal_bitsnum() != 0) {
    _this->_internal_set_bitsnum(from._internal_bitsnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Character_ServerMovePacked_Params::CopyFrom(const Character_ServerMovePacked_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Character_ServerMovePacked_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Character_ServerMovePacked_Params::IsInitialized() const {
  return true;
}

void Character_ServerMovePacked_Params::InternalSwap(Character_ServerMovePacked_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.packedbits_, lhs_arena,
      &other->_impl_.packedbits_, rhs_arena
  );
  swap(_impl_.bitsnum_, other->_impl_.bitsnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Character_ServerMovePacked_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[12]);
}

// ===================================================================

class Character_ClientMoveResponsePacked_Params::_Internal {
 public:
};

Character_ClientMoveResponsePacked_Params::Character_ClientMoveResponsePacked_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Character_ClientMoveResponsePacked_Params)
}
Character_ClientMoveResponsePacked_Params::Character_ClientMoveResponsePacked_Params(const Character_ClientMoveResponsePacked_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Character_ClientMoveResponsePacked_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_packedbits().empty()) {
    _this->_impl_.packedbits_.Set(from._internal_packedbits(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.bitsnum_ = from._impl_.bitsnum_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.Character_ClientMoveResponsePacked_Params)
}

inline void Character_ClientMoveResponsePacked_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Character_ClientMoveResponsePacked_Params::~Character_ClientMoveResponsePacked_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Character_ClientMoveResponsePacked_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Character_ClientMoveResponsePacked_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packedbits_.Destroy();
}

void Character_ClientMoveResponsePacked_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Character_ClientMoveResponsePacked_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packedbits_.ClearToEmpty();
  _impl_.bitsnum_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Character_ClientMoveResponsePacked_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 bitsNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.bitsnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes packedBits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_packedbits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Character_ClientMoveResponsePacked_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bitsnum(), target);
  }

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_packedbits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Character_ClientMoveResponsePacked_Params)
  return target;
}

size_t Character_ClientMoveResponsePacked_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_packedbits());
  }

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitsnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Character_ClientMoveResponsePacked_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Character_ClientMoveResponsePacked_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Character_ClientMoveResponsePacked_Params::GetClassData() const { return &_class_data_; }


void Character_ClientMoveResponsePacked_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Character_ClientMoveResponsePacked_Params*>(&to_msg);
  auto& from = static_cast<const Character_ClientMoveResponsePacked_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_packedbits().empty()) {
    _this->_internal_set_packedbits(from._internal_packedbits());
  }
  if (from._internal_bitsnum() != 0) {
    _this->_internal_set_bitsnum(from._internal_bitsnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Character_ClientMoveResponsePacked_Params::CopyFrom(const Character_ClientMoveResponsePacked_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Character_ClientMoveResponsePacked_Params::IsInitialized() const {
  return true;
}

void Character_ClientMoveResponsePacked_Params::InternalSwap(Character_ClientMoveResponsePacked_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.packedbits_, lhs_arena,
      &other->_impl_.packedbits_, rhs_arena
  );
  swap(_impl_.bitsnum_, other->_impl_.bitsnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Character_ClientMoveResponsePacked_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[13]);
}

// ===================================================================

class PlayerState::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerState>()._impl_._has_bits_);
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_playername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlayerState::PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerState)
}
PlayerState::PlayerState(const PlayerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.playerid_){}
    , decltype(_impl_.ping_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_playername()) {
    _this->_impl_.playername_.Set(from._internal_playername(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.removed_, &from._impl_.removed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ping_) -
    reinterpret_cast<char*>(&_impl_.removed_)) + sizeof(_impl_.ping_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerState)
}

inline void PlayerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.score_){0}
    , decltype(_impl_.playerid_){0}
    , decltype(_impl_.ping_){0u}
  };
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerState::~PlayerState() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.playername_.Destroy();
}

void PlayerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.playername_.ClearNonDefaultToEmpty();
  }
  _impl_.removed_ = false;
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ping_) -
        reinterpret_cast<char*>(&_impl_.score_)) + sizeof(_impl_.ping_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float score = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 playerId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_playerid(&has_bits);
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ping = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ping(&has_bits);
          _impl_.ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string playerName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_playername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerState.playerName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional float score = 2;
  if (_internal_has_score()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_score(), target);
  }

  // optional int32 playerId = 3;
  if (_internal_has_playerid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_playerid(), target);
  }

  // optional uint32 ping = 4;
  if (_internal_has_ping()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ping(), target);
  }

  // optional string playerName = 5;
  if (_internal_has_playername()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_playername().data(), static_cast<int>(this->_internal_playername().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerState.playerName");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_playername(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerState)
  return target;
}

size_t PlayerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string playerName = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_playername());
  }

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x0000000eu) {
    // optional float score = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional int32 playerId = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
    }

    // optional uint32 ping = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ping());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerState::GetClassData() const { return &_class_data_; }


void PlayerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerState*>(&to_msg);
  auto& from = static_cast<const PlayerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playername()) {
    _this->_internal_set_playername(from._internal_playername());
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.playerid_ = from._impl_.playerid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ping_ = from._impl_.ping_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerState::CopyFrom(const PlayerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerState::IsInitialized() const {
  return true;
}

void PlayerState::InternalSwap(PlayerState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.playername_, lhs_arena,
      &other->_impl_.playername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerState, _impl_.ping_)
      + sizeof(PlayerState::_impl_.ping_)
      - PROTOBUF_FIELD_OFFSET(PlayerState, _impl_.removed_)>(
          reinterpret_cast<char*>(&_impl_.removed_),
          reinterpret_cast<char*>(&other->_impl_.removed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[14]);
}

// ===================================================================

class ControllerState::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& playerstate(const ControllerState* msg);
  static const ::unrealpb::UnrealObjectRef& pawn(const ControllerState* msg);
};

const ::unrealpb::UnrealObjectRef&
ControllerState::_Internal::playerstate(const ControllerState* msg) {
  return *msg->_impl_.playerstate_;
}
const ::unrealpb::UnrealObjectRef&
ControllerState::_Internal::pawn(const ControllerState* msg) {
  return *msg->_impl_.pawn_;
}
ControllerState::ControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ControllerState)
}
ControllerState::ControllerState(const ControllerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControllerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.playerstate_){nullptr}
    , decltype(_impl_.pawn_){nullptr}
    , decltype(_impl_.removed_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_playerstate()) {
    _this->_impl_.playerstate_ = new ::unrealpb::UnrealObjectRef(*from._impl_.playerstate_);
  }
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  _this->_impl_.removed_ = from._impl_.removed_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.ControllerState)
}

inline void ControllerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.playerstate_){nullptr}
    , decltype(_impl_.pawn_){nullptr}
    , decltype(_impl_.removed_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControllerState::~ControllerState() {
  // @@protoc_insertion_point(destructor:unrealpb.ControllerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControllerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.playerstate_;
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void ControllerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControllerState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ControllerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.playerstate_ != nullptr) {
    delete _impl_.playerstate_;
  }
  _impl_.playerstate_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _impl_.removed_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControllerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef playerState = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef pawn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ControllerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ControllerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // .unrealpb.UnrealObjectRef playerState = 2;
  if (this->_internal_has_playerstate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::playerstate(this),
        _Internal::playerstate(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.UnrealObjectRef pawn = 3;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ControllerState)
  return target;
}

size_t ControllerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ControllerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef playerState = 2;
  if (this->_internal_has_playerstate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.playerstate_);
  }

  // .unrealpb.UnrealObjectRef pawn = 3;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControllerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControllerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControllerState::GetClassData() const { return &_class_data_; }


void ControllerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControllerState*>(&to_msg);
  auto& from = static_cast<const ControllerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ControllerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playerstate()) {
    _this->_internal_mutable_playerstate()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_playerstate());
  }
  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControllerState::CopyFrom(const ControllerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ControllerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControllerState::IsInitialized() const {
  return true;
}

void ControllerState::InternalSwap(ControllerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControllerState, _impl_.removed_)
      + sizeof(ControllerState::_impl_.removed_)
      - PROTOBUF_FIELD_OFFSET(ControllerState, _impl_.playerstate_)>(
          reinterpret_cast<char*>(&_impl_.playerstate_),
          reinterpret_cast<char*>(&other->_impl_.playerstate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControllerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[15]);
}

// ===================================================================

class Controller_ClientSetLocation_Params::_Internal {
 public:
  static const ::unrealpb::FVector& newlocation(const Controller_ClientSetLocation_Params* msg);
  static const ::unrealpb::FVector& newrotation(const Controller_ClientSetLocation_Params* msg);
};

const ::unrealpb::FVector&
Controller_ClientSetLocation_Params::_Internal::newlocation(const Controller_ClientSetLocation_Params* msg) {
  return *msg->_impl_.newlocation_;
}
const ::unrealpb::FVector&
Controller_ClientSetLocation_Params::_Internal::newrotation(const Controller_ClientSetLocation_Params* msg) {
  return *msg->_impl_.newrotation_;
}
Controller_ClientSetLocation_Params::Controller_ClientSetLocation_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Controller_ClientSetLocation_Params)
}
Controller_ClientSetLocation_Params::Controller_ClientSetLocation_Params(const Controller_ClientSetLocation_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Controller_ClientSetLocation_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newlocation_){nullptr}
    , decltype(_impl_.newrotation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newlocation()) {
    _this->_impl_.newlocation_ = new ::unrealpb::FVector(*from._impl_.newlocation_);
  }
  if (from._internal_has_newrotation()) {
    _this->_impl_.newrotation_ = new ::unrealpb::FVector(*from._impl_.newrotation_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.Controller_ClientSetLocation_Params)
}

inline void Controller_ClientSetLocation_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newlocation_){nullptr}
    , decltype(_impl_.newrotation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Controller_ClientSetLocation_Params::~Controller_ClientSetLocation_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Controller_ClientSetLocation_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Controller_ClientSetLocation_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.newlocation_;
  if (this != internal_default_instance()) delete _impl_.newrotation_;
}

void Controller_ClientSetLocation_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Controller_ClientSetLocation_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Controller_ClientSetLocation_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.newlocation_ != nullptr) {
    delete _impl_.newlocation_;
  }
  _impl_.newlocation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.newrotation_ != nullptr) {
    delete _impl_.newrotation_;
  }
  _impl_.newrotation_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Controller_ClientSetLocation_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector newLocation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newlocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.FVector newRotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Controller_ClientSetLocation_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Controller_ClientSetLocation_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector newLocation = 1;
  if (this->_internal_has_newlocation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newlocation(this),
        _Internal::newlocation(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.FVector newRotation = 2;
  if (this->_internal_has_newrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::newrotation(this),
        _Internal::newrotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Controller_ClientSetLocation_Params)
  return target;
}

size_t Controller_ClientSetLocation_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Controller_ClientSetLocation_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector newLocation = 1;
  if (this->_internal_has_newlocation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newlocation_);
  }

  // .unrealpb.FVector newRotation = 2;
  if (this->_internal_has_newrotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newrotation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Controller_ClientSetLocation_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Controller_ClientSetLocation_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Controller_ClientSetLocation_Params::GetClassData() const { return &_class_data_; }


void Controller_ClientSetLocation_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Controller_ClientSetLocation_Params*>(&to_msg);
  auto& from = static_cast<const Controller_ClientSetLocation_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Controller_ClientSetLocation_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newlocation()) {
    _this->_internal_mutable_newlocation()->::unrealpb::FVector::MergeFrom(
        from._internal_newlocation());
  }
  if (from._internal_has_newrotation()) {
    _this->_internal_mutable_newrotation()->::unrealpb::FVector::MergeFrom(
        from._internal_newrotation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Controller_ClientSetLocation_Params::CopyFrom(const Controller_ClientSetLocation_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Controller_ClientSetLocation_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Controller_ClientSetLocation_Params::IsInitialized() const {
  return true;
}

void Controller_ClientSetLocation_Params::InternalSwap(Controller_ClientSetLocation_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Controller_ClientSetLocation_Params, _impl_.newrotation_)
      + sizeof(Controller_ClientSetLocation_Params::_impl_.newrotation_)
      - PROTOBUF_FIELD_OFFSET(Controller_ClientSetLocation_Params, _impl_.newlocation_)>(
          reinterpret_cast<char*>(&_impl_.newlocation_),
          reinterpret_cast<char*>(&other->_impl_.newlocation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Controller_ClientSetLocation_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[16]);
}

// ===================================================================

class Controller_ClientSetRotation_Params::_Internal {
 public:
  static const ::unrealpb::FVector& newrotation(const Controller_ClientSetRotation_Params* msg);
};

const ::unrealpb::FVector&
Controller_ClientSetRotation_Params::_Internal::newrotation(const Controller_ClientSetRotation_Params* msg) {
  return *msg->_impl_.newrotation_;
}
Controller_ClientSetRotation_Params::Controller_ClientSetRotation_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Controller_ClientSetRotation_Params)
}
Controller_ClientSetRotation_Params::Controller_ClientSetRotation_Params(const Controller_ClientSetRotation_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Controller_ClientSetRotation_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newrotation_){nullptr}
    , decltype(_impl_.bresetcamera_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newrotation()) {
    _this->_impl_.newrotation_ = new ::unrealpb::FVector(*from._impl_.newrotation_);
  }
  _this->_impl_.bresetcamera_ = from._impl_.bresetcamera_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.Controller_ClientSetRotation_Params)
}

inline void Controller_ClientSetRotation_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newrotation_){nullptr}
    , decltype(_impl_.bresetcamera_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Controller_ClientSetRotation_Params::~Controller_ClientSetRotation_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Controller_ClientSetRotation_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Controller_ClientSetRotation_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.newrotation_;
}

void Controller_ClientSetRotation_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Controller_ClientSetRotation_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Controller_ClientSetRotation_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.newrotation_ != nullptr) {
    delete _impl_.newrotation_;
  }
  _impl_.newrotation_ = nullptr;
  _impl_.bresetcamera_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Controller_ClientSetRotation_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector newRotation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bResetCamera = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.bresetcamera_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Controller_ClientSetRotation_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Controller_ClientSetRotation_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector newRotation = 1;
  if (this->_internal_has_newrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newrotation(this),
        _Internal::newrotation(this).GetCachedSize(), target, stream);
  }

  // bool bResetCamera = 2;
  if (this->_internal_bresetcamera() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_bresetcamera(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Controller_ClientSetRotation_Params)
  return target;
}

size_t Controller_ClientSetRotation_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Controller_ClientSetRotation_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector newRotation = 1;
  if (this->_internal_has_newrotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newrotation_);
  }

  // bool bResetCamera = 2;
  if (this->_internal_bresetcamera() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Controller_ClientSetRotation_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Controller_ClientSetRotation_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Controller_ClientSetRotation_Params::GetClassData() const { return &_class_data_; }


void Controller_ClientSetRotation_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Controller_ClientSetRotation_Params*>(&to_msg);
  auto& from = static_cast<const Controller_ClientSetRotation_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Controller_ClientSetRotation_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newrotation()) {
    _this->_internal_mutable_newrotation()->::unrealpb::FVector::MergeFrom(
        from._internal_newrotation());
  }
  if (from._internal_bresetcamera() != 0) {
    _this->_internal_set_bresetcamera(from._internal_bresetcamera());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Controller_ClientSetRotation_Params::CopyFrom(const Controller_ClientSetRotation_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Controller_ClientSetRotation_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Controller_ClientSetRotation_Params::IsInitialized() const {
  return true;
}

void Controller_ClientSetRotation_Params::InternalSwap(Controller_ClientSetRotation_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Controller_ClientSetRotation_Params, _impl_.bresetcamera_)
      + sizeof(Controller_ClientSetRotation_Params::_impl_.bresetcamera_)
      - PROTOBUF_FIELD_OFFSET(Controller_ClientSetRotation_Params, _impl_.newrotation_)>(
          reinterpret_cast<char*>(&_impl_.newrotation_),
          reinterpret_cast<char*>(&other->_impl_.newrotation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Controller_ClientSetRotation_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[17]);
}

// ===================================================================

class PlayerControllerState::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerControllerState>()._impl_._has_bits_);
  static const ::unrealpb::FVector& targetviewrotation(const PlayerControllerState* msg);
  static void set_has_targetviewrotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& spawnlocation(const PlayerControllerState* msg);
  static void set_has_spawnlocation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::unrealpb::FVector&
PlayerControllerState::_Internal::targetviewrotation(const PlayerControllerState* msg) {
  return *msg->_impl_.targetviewrotation_;
}
const ::unrealpb::FVector&
PlayerControllerState::_Internal::spawnlocation(const PlayerControllerState* msg) {
  return *msg->_impl_.spawnlocation_;
}
PlayerControllerState::PlayerControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerControllerState)
}
PlayerControllerState::PlayerControllerState(const PlayerControllerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerControllerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetviewrotation_){nullptr}
    , decltype(_impl_.spawnlocation_){nullptr}
    , decltype(_impl_.removed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_targetviewrotation()) {
    _this->_impl_.targetviewrotation_ = new ::unrealpb::FVector(*from._impl_.targetviewrotation_);
  }
  if (from._internal_has_spawnlocation()) {
    _this->_impl_.spawnlocation_ = new ::unrealpb::FVector(*from._impl_.spawnlocation_);
  }
  _this->_impl_.removed_ = from._impl_.removed_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerControllerState)
}

inline void PlayerControllerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetviewrotation_){nullptr}
    , decltype(_impl_.spawnlocation_){nullptr}
    , decltype(_impl_.removed_){false}
  };
}

PlayerControllerState::~PlayerControllerState() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerControllerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerControllerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.targetviewrotation_;
  if (this != internal_default_instance()) delete _impl_.spawnlocation_;
}

void PlayerControllerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerControllerState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerControllerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.targetviewrotation_ != nullptr);
      _impl_.targetviewrotation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spawnlocation_ != nullptr);
      _impl_.spawnlocation_->Clear();
    }
  }
  _impl_.removed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerControllerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector targetViewRotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetviewrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector spawnLocation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_spawnlocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerControllerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerControllerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional .unrealpb.FVector targetViewRotation = 2;
  if (_internal_has_targetviewrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::targetviewrotation(this),
        _Internal::targetviewrotation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector spawnLocation = 3;
  if (_internal_has_spawnlocation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::spawnlocation(this),
        _Internal::spawnlocation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerControllerState)
  return target;
}

size_t PlayerControllerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerControllerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .unrealpb.FVector targetViewRotation = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.targetviewrotation_);
    }

    // optional .unrealpb.FVector spawnLocation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spawnlocation_);
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerControllerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerControllerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerControllerState::GetClassData() const { return &_class_data_; }


void PlayerControllerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerControllerState*>(&to_msg);
  auto& from = static_cast<const PlayerControllerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerControllerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_targetviewrotation()->::unrealpb::FVector::MergeFrom(
          from._internal_targetviewrotation());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spawnlocation()->::unrealpb::FVector::MergeFrom(
          from._internal_spawnlocation());
    }
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerControllerState::CopyFrom(const PlayerControllerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerControllerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerControllerState::IsInitialized() const {
  return true;
}

void PlayerControllerState::InternalSwap(PlayerControllerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerControllerState, _impl_.removed_)
      + sizeof(PlayerControllerState::_impl_.removed_)
      - PROTOBUF_FIELD_OFFSET(PlayerControllerState, _impl_.targetviewrotation_)>(
          reinterpret_cast<char*>(&_impl_.targetviewrotation_),
          reinterpret_cast<char*>(&other->_impl_.targetviewrotation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerControllerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[18]);
}

// ===================================================================

class PlayerController_ServerUpdateCamera_Params::_Internal {
 public:
  static const ::unrealpb::FVector& camloc(const PlayerController_ServerUpdateCamera_Params* msg);
};

const ::unrealpb::FVector&
PlayerController_ServerUpdateCamera_Params::_Internal::camloc(const PlayerController_ServerUpdateCamera_Params* msg) {
  return *msg->_impl_.camloc_;
}
PlayerController_ServerUpdateCamera_Params::PlayerController_ServerUpdateCamera_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ServerUpdateCamera_Params)
}
PlayerController_ServerUpdateCamera_Params::PlayerController_ServerUpdateCamera_Params(const PlayerController_ServerUpdateCamera_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ServerUpdateCamera_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.camloc_){nullptr}
    , decltype(_impl_.campitchandyaw_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_camloc()) {
    _this->_impl_.camloc_ = new ::unrealpb::FVector(*from._impl_.camloc_);
  }
  _this->_impl_.campitchandyaw_ = from._impl_.campitchandyaw_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ServerUpdateCamera_Params)
}

inline void PlayerController_ServerUpdateCamera_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.camloc_){nullptr}
    , decltype(_impl_.campitchandyaw_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ServerUpdateCamera_Params::~PlayerController_ServerUpdateCamera_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ServerUpdateCamera_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ServerUpdateCamera_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.camloc_;
}

void PlayerController_ServerUpdateCamera_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ServerUpdateCamera_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.camloc_ != nullptr) {
    delete _impl_.camloc_;
  }
  _impl_.camloc_ = nullptr;
  _impl_.campitchandyaw_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ServerUpdateCamera_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector camLoc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_camloc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 camPitchAndYaw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.campitchandyaw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ServerUpdateCamera_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector camLoc = 1;
  if (this->_internal_has_camloc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::camloc(this),
        _Internal::camloc(this).GetCachedSize(), target, stream);
  }

  // int32 camPitchAndYaw = 2;
  if (this->_internal_campitchandyaw() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_campitchandyaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ServerUpdateCamera_Params)
  return target;
}

size_t PlayerController_ServerUpdateCamera_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector camLoc = 1;
  if (this->_internal_has_camloc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.camloc_);
  }

  // int32 camPitchAndYaw = 2;
  if (this->_internal_campitchandyaw() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_campitchandyaw());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ServerUpdateCamera_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ServerUpdateCamera_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ServerUpdateCamera_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ServerUpdateCamera_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ServerUpdateCamera_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ServerUpdateCamera_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_camloc()) {
    _this->_internal_mutable_camloc()->::unrealpb::FVector::MergeFrom(
        from._internal_camloc());
  }
  if (from._internal_campitchandyaw() != 0) {
    _this->_internal_set_campitchandyaw(from._internal_campitchandyaw());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ServerUpdateCamera_Params::CopyFrom(const PlayerController_ServerUpdateCamera_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ServerUpdateCamera_Params::IsInitialized() const {
  return true;
}

void PlayerController_ServerUpdateCamera_Params::InternalSwap(PlayerController_ServerUpdateCamera_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ServerUpdateCamera_Params, _impl_.campitchandyaw_)
      + sizeof(PlayerController_ServerUpdateCamera_Params::_impl_.campitchandyaw_)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ServerUpdateCamera_Params, _impl_.camloc_)>(
          reinterpret_cast<char*>(&_impl_.camloc_),
          reinterpret_cast<char*>(&other->_impl_.camloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ServerUpdateCamera_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[19]);
}

// ===================================================================

class PlayerController_ClientSetHUD_Params::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerController_ClientSetHUD_Params>()._impl_._has_bits_);
  static void set_has_hudclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlayerController_ClientSetHUD_Params::PlayerController_ClientSetHUD_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientSetHUD_Params)
}
PlayerController_ClientSetHUD_Params::PlayerController_ClientSetHUD_Params(const PlayerController_ClientSetHUD_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientSetHUD_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hudclassname_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hudclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hudclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hudclassname()) {
    _this->_impl_.hudclassname_.Set(from._internal_hudclassname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientSetHUD_Params)
}

inline void PlayerController_ClientSetHUD_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hudclassname_){}
  };
  _impl_.hudclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hudclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerController_ClientSetHUD_Params::~PlayerController_ClientSetHUD_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientSetHUD_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientSetHUD_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hudclassname_.Destroy();
}

void PlayerController_ClientSetHUD_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientSetHUD_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientSetHUD_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.hudclassname_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientSetHUD_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string hudClassName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hudclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerController_ClientSetHUD_Params.hudClassName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientSetHUD_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientSetHUD_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string hudClassName = 1;
  if (_internal_has_hudclassname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hudclassname().data(), static_cast<int>(this->_internal_hudclassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerController_ClientSetHUD_Params.hudClassName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hudclassname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientSetHUD_Params)
  return target;
}

size_t PlayerController_ClientSetHUD_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientSetHUD_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string hudClassName = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hudclassname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientSetHUD_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientSetHUD_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientSetHUD_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientSetHUD_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientSetHUD_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientSetHUD_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientSetHUD_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hudclassname()) {
    _this->_internal_set_hudclassname(from._internal_hudclassname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientSetHUD_Params::CopyFrom(const PlayerController_ClientSetHUD_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientSetHUD_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientSetHUD_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientSetHUD_Params::InternalSwap(PlayerController_ClientSetHUD_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hudclassname_, lhs_arena,
      &other->_impl_.hudclassname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientSetHUD_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[20]);
}

// ===================================================================

class PlayerController_ClientSetViewTarget_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& actor(const PlayerController_ClientSetViewTarget_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientSetViewTarget_Params::_Internal::actor(const PlayerController_ClientSetViewTarget_Params* msg) {
  return *msg->_impl_.actor_;
}
PlayerController_ClientSetViewTarget_Params::PlayerController_ClientSetViewTarget_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientSetViewTarget_Params)
}
PlayerController_ClientSetViewTarget_Params::PlayerController_ClientSetViewTarget_Params(const PlayerController_ClientSetViewTarget_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientSetViewTarget_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actor_){nullptr}
    , decltype(_impl_.blendtime_){}
    , decltype(_impl_.blendfunction_){}
    , decltype(_impl_.blendexp_){}
    , decltype(_impl_.blockoutgoing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_actor()) {
    _this->_impl_.actor_ = new ::unrealpb::UnrealObjectRef(*from._impl_.actor_);
  }
  ::memcpy(&_impl_.blendtime_, &from._impl_.blendtime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blockoutgoing_) -
    reinterpret_cast<char*>(&_impl_.blendtime_)) + sizeof(_impl_.blockoutgoing_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientSetViewTarget_Params)
}

inline void PlayerController_ClientSetViewTarget_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.actor_){nullptr}
    , decltype(_impl_.blendtime_){0}
    , decltype(_impl_.blendfunction_){0u}
    , decltype(_impl_.blendexp_){0}
    , decltype(_impl_.blockoutgoing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientSetViewTarget_Params::~PlayerController_ClientSetViewTarget_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientSetViewTarget_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientSetViewTarget_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.actor_;
}

void PlayerController_ClientSetViewTarget_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientSetViewTarget_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.actor_ != nullptr) {
    delete _impl_.actor_;
  }
  _impl_.actor_ = nullptr;
  ::memset(&_impl_.blendtime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.blockoutgoing_) -
      reinterpret_cast<char*>(&_impl_.blendtime_)) + sizeof(_impl_.blockoutgoing_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientSetViewTarget_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef actor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_actor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float blendTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.blendtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 blendFunction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.blendfunction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float blendExp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.blendexp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool bLockOutgoing = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.blockoutgoing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientSetViewTarget_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef actor = 1;
  if (this->_internal_has_actor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::actor(this),
        _Internal::actor(this).GetCachedSize(), target, stream);
  }

  // float blendTime = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendtime = this->_internal_blendtime();
  uint32_t raw_blendtime;
  memcpy(&raw_blendtime, &tmp_blendtime, sizeof(tmp_blendtime));
  if (raw_blendtime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_blendtime(), target);
  }

  // uint32 blendFunction = 3;
  if (this->_internal_blendfunction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_blendfunction(), target);
  }

  // float blendExp = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendexp = this->_internal_blendexp();
  uint32_t raw_blendexp;
  memcpy(&raw_blendexp, &tmp_blendexp, sizeof(tmp_blendexp));
  if (raw_blendexp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_blendexp(), target);
  }

  // bool bLockOutgoing = 5;
  if (this->_internal_blockoutgoing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_blockoutgoing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientSetViewTarget_Params)
  return target;
}

size_t PlayerController_ClientSetViewTarget_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef actor = 1;
  if (this->_internal_has_actor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.actor_);
  }

  // float blendTime = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendtime = this->_internal_blendtime();
  uint32_t raw_blendtime;
  memcpy(&raw_blendtime, &tmp_blendtime, sizeof(tmp_blendtime));
  if (raw_blendtime != 0) {
    total_size += 1 + 4;
  }

  // uint32 blendFunction = 3;
  if (this->_internal_blendfunction() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blendfunction());
  }

  // float blendExp = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendexp = this->_internal_blendexp();
  uint32_t raw_blendexp;
  memcpy(&raw_blendexp, &tmp_blendexp, sizeof(tmp_blendexp));
  if (raw_blendexp != 0) {
    total_size += 1 + 4;
  }

  // bool bLockOutgoing = 5;
  if (this->_internal_blockoutgoing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientSetViewTarget_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientSetViewTarget_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientSetViewTarget_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientSetViewTarget_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientSetViewTarget_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientSetViewTarget_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_actor()) {
    _this->_internal_mutable_actor()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_actor());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendtime = from._internal_blendtime();
  uint32_t raw_blendtime;
  memcpy(&raw_blendtime, &tmp_blendtime, sizeof(tmp_blendtime));
  if (raw_blendtime != 0) {
    _this->_internal_set_blendtime(from._internal_blendtime());
  }
  if (from._internal_blendfunction() != 0) {
    _this->_internal_set_blendfunction(from._internal_blendfunction());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendexp = from._internal_blendexp();
  uint32_t raw_blendexp;
  memcpy(&raw_blendexp, &tmp_blendexp, sizeof(tmp_blendexp));
  if (raw_blendexp != 0) {
    _this->_internal_set_blendexp(from._internal_blendexp());
  }
  if (from._internal_blockoutgoing() != 0) {
    _this->_internal_set_blockoutgoing(from._internal_blockoutgoing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientSetViewTarget_Params::CopyFrom(const PlayerController_ClientSetViewTarget_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientSetViewTarget_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientSetViewTarget_Params::InternalSwap(PlayerController_ClientSetViewTarget_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ClientSetViewTarget_Params, _impl_.blockoutgoing_)
      + sizeof(PlayerController_ClientSetViewTarget_Params::_impl_.blockoutgoing_)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ClientSetViewTarget_Params, _impl_.actor_)>(
          reinterpret_cast<char*>(&_impl_.actor_),
          reinterpret_cast<char*>(&other->_impl_.actor_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientSetViewTarget_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[21]);
}

// ===================================================================

class PlayerController_ClientEnableNetworkVoice_Params::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerController_ClientEnableNetworkVoice_Params>()._impl_._has_bits_);
  static void set_has_benable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlayerController_ClientEnableNetworkVoice_Params::PlayerController_ClientEnableNetworkVoice_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
}
PlayerController_ClientEnableNetworkVoice_Params::PlayerController_ClientEnableNetworkVoice_Params(const PlayerController_ClientEnableNetworkVoice_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientEnableNetworkVoice_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.benable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.benable_ = from._impl_.benable_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
}

inline void PlayerController_ClientEnableNetworkVoice_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.benable_){false}
  };
}

PlayerController_ClientEnableNetworkVoice_Params::~PlayerController_ClientEnableNetworkVoice_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientEnableNetworkVoice_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerController_ClientEnableNetworkVoice_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientEnableNetworkVoice_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.benable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientEnableNetworkVoice_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool bEnable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_benable(&has_bits);
          _impl_.benable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientEnableNetworkVoice_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool bEnable = 1;
  if (_internal_has_benable()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_benable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  return target;
}

size_t PlayerController_ClientEnableNetworkVoice_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool bEnable = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientEnableNetworkVoice_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientEnableNetworkVoice_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientEnableNetworkVoice_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientEnableNetworkVoice_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientEnableNetworkVoice_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientEnableNetworkVoice_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_benable()) {
    _this->_internal_set_benable(from._internal_benable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientEnableNetworkVoice_Params::CopyFrom(const PlayerController_ClientEnableNetworkVoice_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientEnableNetworkVoice_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientEnableNetworkVoice_Params::InternalSwap(PlayerController_ClientEnableNetworkVoice_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.benable_, other->_impl_.benable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientEnableNetworkVoice_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[22]);
}

// ===================================================================

class PlayerController_ClientCapBandwidth_Params::_Internal {
 public:
};

PlayerController_ClientCapBandwidth_Params::PlayerController_ClientCapBandwidth_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientCapBandwidth_Params)
}
PlayerController_ClientCapBandwidth_Params::PlayerController_ClientCapBandwidth_Params(const PlayerController_ClientCapBandwidth_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientCapBandwidth_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cap_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.cap_ = from._impl_.cap_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientCapBandwidth_Params)
}

inline void PlayerController_ClientCapBandwidth_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cap_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientCapBandwidth_Params::~PlayerController_ClientCapBandwidth_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientCapBandwidth_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientCapBandwidth_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerController_ClientCapBandwidth_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientCapBandwidth_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cap_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientCapBandwidth_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 cap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.cap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientCapBandwidth_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 cap = 1;
  if (this->_internal_cap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientCapBandwidth_Params)
  return target;
}

size_t PlayerController_ClientCapBandwidth_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 cap = 1;
  if (this->_internal_cap() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cap());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientCapBandwidth_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientCapBandwidth_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientCapBandwidth_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientCapBandwidth_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientCapBandwidth_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientCapBandwidth_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_cap() != 0) {
    _this->_internal_set_cap(from._internal_cap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientCapBandwidth_Params::CopyFrom(const PlayerController_ClientCapBandwidth_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientCapBandwidth_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientCapBandwidth_Params::InternalSwap(PlayerController_ClientCapBandwidth_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.cap_, other->_impl_.cap_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientCapBandwidth_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[23]);
}

// ===================================================================

class PlayerController_ClientRestart_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& pawn(const PlayerController_ClientRestart_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientRestart_Params::_Internal::pawn(const PlayerController_ClientRestart_Params* msg) {
  return *msg->_impl_.pawn_;
}
PlayerController_ClientRestart_Params::PlayerController_ClientRestart_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientRestart_Params)
}
PlayerController_ClientRestart_Params::PlayerController_ClientRestart_Params(const PlayerController_ClientRestart_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientRestart_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientRestart_Params)
}

inline void PlayerController_ClientRestart_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientRestart_Params::~PlayerController_ClientRestart_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientRestart_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientRestart_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void PlayerController_ClientRestart_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientRestart_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientRestart_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientRestart_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef pawn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientRestart_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientRestart_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientRestart_Params)
  return target;
}

size_t PlayerController_ClientRestart_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientRestart_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientRestart_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientRestart_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientRestart_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientRestart_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientRestart_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientRestart_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientRestart_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientRestart_Params::CopyFrom(const PlayerController_ClientRestart_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientRestart_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientRestart_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientRestart_Params::InternalSwap(PlayerController_ClientRestart_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pawn_, other->_impl_.pawn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientRestart_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[24]);
}

// ===================================================================

class PlayerController_ClientSetCameraMode_Params::_Internal {
 public:
};

PlayerController_ClientSetCameraMode_Params::PlayerController_ClientSetCameraMode_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientSetCameraMode_Params)
}
PlayerController_ClientSetCameraMode_Params::PlayerController_ClientSetCameraMode_Params(const PlayerController_ClientSetCameraMode_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientSetCameraMode_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newcammode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newcammode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newcammode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_newcammode().empty()) {
    _this->_impl_.newcammode_.Set(from._internal_newcammode(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientSetCameraMode_Params)
}

inline void PlayerController_ClientSetCameraMode_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newcammode_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.newcammode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newcammode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerController_ClientSetCameraMode_Params::~PlayerController_ClientSetCameraMode_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientSetCameraMode_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientSetCameraMode_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.newcammode_.Destroy();
}

void PlayerController_ClientSetCameraMode_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientSetCameraMode_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.newcammode_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientSetCameraMode_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string newCamMode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newcammode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerController_ClientSetCameraMode_Params.newCamMode"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientSetCameraMode_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string newCamMode = 1;
  if (!this->_internal_newcammode().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newcammode().data(), static_cast<int>(this->_internal_newcammode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerController_ClientSetCameraMode_Params.newCamMode");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newcammode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientSetCameraMode_Params)
  return target;
}

size_t PlayerController_ClientSetCameraMode_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string newCamMode = 1;
  if (!this->_internal_newcammode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newcammode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientSetCameraMode_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientSetCameraMode_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientSetCameraMode_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientSetCameraMode_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientSetCameraMode_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientSetCameraMode_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_newcammode().empty()) {
    _this->_internal_set_newcammode(from._internal_newcammode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientSetCameraMode_Params::CopyFrom(const PlayerController_ClientSetCameraMode_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientSetCameraMode_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientSetCameraMode_Params::InternalSwap(PlayerController_ClientSetCameraMode_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newcammode_, lhs_arena,
      &other->_impl_.newcammode_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientSetCameraMode_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[25]);
}

// ===================================================================

class PlayerController_ClientRetryClientRestart_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& pawn(const PlayerController_ClientRetryClientRestart_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientRetryClientRestart_Params::_Internal::pawn(const PlayerController_ClientRetryClientRestart_Params* msg) {
  return *msg->_impl_.pawn_;
}
PlayerController_ClientRetryClientRestart_Params::PlayerController_ClientRetryClientRestart_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientRetryClientRestart_Params)
}
PlayerController_ClientRetryClientRestart_Params::PlayerController_ClientRetryClientRestart_Params(const PlayerController_ClientRetryClientRestart_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientRetryClientRestart_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientRetryClientRestart_Params)
}

inline void PlayerController_ClientRetryClientRestart_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientRetryClientRestart_Params::~PlayerController_ClientRetryClientRestart_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientRetryClientRestart_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void PlayerController_ClientRetryClientRestart_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientRetryClientRestart_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientRetryClientRestart_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef pawn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientRetryClientRestart_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  return target;
}

size_t PlayerController_ClientRetryClientRestart_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientRetryClientRestart_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientRetryClientRestart_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientRetryClientRestart_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientRetryClientRestart_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientRetryClientRestart_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientRetryClientRestart_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientRetryClientRestart_Params::CopyFrom(const PlayerController_ClientRetryClientRestart_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientRetryClientRestart_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientRetryClientRestart_Params::InternalSwap(PlayerController_ClientRetryClientRestart_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pawn_, other->_impl_.pawn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientRetryClientRestart_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[26]);
}

// ===================================================================

class PlayerController_ServerSetSpectatorLocation_Params::_Internal {
 public:
  static const ::unrealpb::FVector& newloc(const PlayerController_ServerSetSpectatorLocation_Params* msg);
  static const ::unrealpb::FVector& newrot(const PlayerController_ServerSetSpectatorLocation_Params* msg);
};

const ::unrealpb::FVector&
PlayerController_ServerSetSpectatorLocation_Params::_Internal::newloc(const PlayerController_ServerSetSpectatorLocation_Params* msg) {
  return *msg->_impl_.newloc_;
}
const ::unrealpb::FVector&
PlayerController_ServerSetSpectatorLocation_Params::_Internal::newrot(const PlayerController_ServerSetSpectatorLocation_Params* msg) {
  return *msg->_impl_.newrot_;
}
PlayerController_ServerSetSpectatorLocation_Params::PlayerController_ServerSetSpectatorLocation_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
}
PlayerController_ServerSetSpectatorLocation_Params::PlayerController_ServerSetSpectatorLocation_Params(const PlayerController_ServerSetSpectatorLocation_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ServerSetSpectatorLocation_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newloc_){nullptr}
    , decltype(_impl_.newrot_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newloc()) {
    _this->_impl_.newloc_ = new ::unrealpb::FVector(*from._impl_.newloc_);
  }
  if (from._internal_has_newrot()) {
    _this->_impl_.newrot_ = new ::unrealpb::FVector(*from._impl_.newrot_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
}

inline void PlayerController_ServerSetSpectatorLocation_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newloc_){nullptr}
    , decltype(_impl_.newrot_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ServerSetSpectatorLocation_Params::~PlayerController_ServerSetSpectatorLocation_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ServerSetSpectatorLocation_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.newloc_;
  if (this != internal_default_instance()) delete _impl_.newrot_;
}

void PlayerController_ServerSetSpectatorLocation_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ServerSetSpectatorLocation_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.newloc_ != nullptr) {
    delete _impl_.newloc_;
  }
  _impl_.newloc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.newrot_ != nullptr) {
    delete _impl_.newrot_;
  }
  _impl_.newrot_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ServerSetSpectatorLocation_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector newLoc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newloc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.FVector newRot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ServerSetSpectatorLocation_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector newLoc = 1;
  if (this->_internal_has_newloc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newloc(this),
        _Internal::newloc(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.FVector newRot = 2;
  if (this->_internal_has_newrot()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::newrot(this),
        _Internal::newrot(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  return target;
}

size_t PlayerController_ServerSetSpectatorLocation_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector newLoc = 1;
  if (this->_internal_has_newloc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newloc_);
  }

  // .unrealpb.FVector newRot = 2;
  if (this->_internal_has_newrot()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newrot_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ServerSetSpectatorLocation_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ServerSetSpectatorLocation_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ServerSetSpectatorLocation_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ServerSetSpectatorLocation_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ServerSetSpectatorLocation_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ServerSetSpectatorLocation_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newloc()) {
    _this->_internal_mutable_newloc()->::unrealpb::FVector::MergeFrom(
        from._internal_newloc());
  }
  if (from._internal_has_newrot()) {
    _this->_internal_mutable_newrot()->::unrealpb::FVector::MergeFrom(
        from._internal_newrot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ServerSetSpectatorLocation_Params::CopyFrom(const PlayerController_ServerSetSpectatorLocation_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ServerSetSpectatorLocation_Params::IsInitialized() const {
  return true;
}

void PlayerController_ServerSetSpectatorLocation_Params::InternalSwap(PlayerController_ServerSetSpectatorLocation_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ServerSetSpectatorLocation_Params, _impl_.newrot_)
      + sizeof(PlayerController_ServerSetSpectatorLocation_Params::_impl_.newrot_)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ServerSetSpectatorLocation_Params, _impl_.newloc_)>(
          reinterpret_cast<char*>(&_impl_.newloc_),
          reinterpret_cast<char*>(&other->_impl_.newloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ServerSetSpectatorLocation_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[27]);
}

// ===================================================================

class PlayerController_ServerAcknowledgePossession_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& pawn(const PlayerController_ServerAcknowledgePossession_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ServerAcknowledgePossession_Params::_Internal::pawn(const PlayerController_ServerAcknowledgePossession_Params* msg) {
  return *msg->_impl_.pawn_;
}
PlayerController_ServerAcknowledgePossession_Params::PlayerController_ServerAcknowledgePossession_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
}
PlayerController_ServerAcknowledgePossession_Params::PlayerController_ServerAcknowledgePossession_Params(const PlayerController_ServerAcknowledgePossession_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ServerAcknowledgePossession_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
}

inline void PlayerController_ServerAcknowledgePossession_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ServerAcknowledgePossession_Params::~PlayerController_ServerAcknowledgePossession_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ServerAcknowledgePossession_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void PlayerController_ServerAcknowledgePossession_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ServerAcknowledgePossession_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ServerAcknowledgePossession_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef pawn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ServerAcknowledgePossession_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  return target;
}

size_t PlayerController_ServerAcknowledgePossession_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ServerAcknowledgePossession_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ServerAcknowledgePossession_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ServerAcknowledgePossession_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ServerAcknowledgePossession_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ServerAcknowledgePossession_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ServerAcknowledgePossession_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ServerAcknowledgePossession_Params::CopyFrom(const PlayerController_ServerAcknowledgePossession_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ServerAcknowledgePossession_Params::IsInitialized() const {
  return true;
}

void PlayerController_ServerAcknowledgePossession_Params::InternalSwap(PlayerController_ServerAcknowledgePossession_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pawn_, other->_impl_.pawn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ServerAcknowledgePossession_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[28]);
}

// ===================================================================

class GameStateBase::_Internal {
 public:
  using HasBits = decltype(std::declval<GameStateBase>()._impl_._has_bits_);
  static void set_has_spectatorclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gamemodeclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_replicatedworldtimeseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_breplicatedhasbegunplay(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GameStateBase::GameStateBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.GameStateBase)
}
GameStateBase::GameStateBase(const GameStateBase& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameStateBase* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spectatorclassname_){}
    , decltype(_impl_.gamemodeclassname_){}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.breplicatedhasbegunplay_){}
    , decltype(_impl_.replicatedworldtimeseconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.spectatorclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spectatorclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_spectatorclassname()) {
    _this->_impl_.spectatorclassname_.Set(from._internal_spectatorclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gamemodeclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamemodeclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gamemodeclassname()) {
    _this->_impl_.gamemodeclassname_.Set(from._internal_gamemodeclassname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.removed_, &from._impl_.removed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.replicatedworldtimeseconds_) -
    reinterpret_cast<char*>(&_impl_.removed_)) + sizeof(_impl_.replicatedworldtimeseconds_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.GameStateBase)
}

inline void GameStateBase::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spectatorclassname_){}
    , decltype(_impl_.gamemodeclassname_){}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.breplicatedhasbegunplay_){false}
    , decltype(_impl_.replicatedworldtimeseconds_){0}
  };
  _impl_.spectatorclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spectatorclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gamemodeclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamemodeclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameStateBase::~GameStateBase() {
  // @@protoc_insertion_point(destructor:unrealpb.GameStateBase)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameStateBase::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.spectatorclassname_.Destroy();
  _impl_.gamemodeclassname_.Destroy();
}

void GameStateBase::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameStateBase::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.GameStateBase)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.spectatorclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.gamemodeclassname_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.removed_ = false;
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.breplicatedhasbegunplay_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.replicatedworldtimeseconds_) -
        reinterpret_cast<char*>(&_impl_.breplicatedhasbegunplay_)) + sizeof(_impl_.replicatedworldtimeseconds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameStateBase::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string spectatorClassName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_spectatorclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.GameStateBase.spectatorClassName"));
        } else
          goto handle_unusual;
        continue;
      // optional string gameModeClassName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gamemodeclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.GameStateBase.gameModeClassName"));
        } else
          goto handle_unusual;
        continue;
      // optional float replicatedWorldTimeSeconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_replicatedworldtimeseconds(&has_bits);
          _impl_.replicatedworldtimeseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool bReplicatedHasBegunPlay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_breplicatedhasbegunplay(&has_bits);
          _impl_.breplicatedhasbegunplay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameStateBase::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.GameStateBase)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional string spectatorClassName = 2;
  if (_internal_has_spectatorclassname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_spectatorclassname().data(), static_cast<int>(this->_internal_spectatorclassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.GameStateBase.spectatorClassName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_spectatorclassname(), target);
  }

  // optional string gameModeClassName = 3;
  if (_internal_has_gamemodeclassname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gamemodeclassname().data(), static_cast<int>(this->_internal_gamemodeclassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.GameStateBase.gameModeClassName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gamemodeclassname(), target);
  }

  // optional float replicatedWorldTimeSeconds = 4;
  if (_internal_has_replicatedworldtimeseconds()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_replicatedworldtimeseconds(), target);
  }

  // optional bool bReplicatedHasBegunPlay = 5;
  if (_internal_has_breplicatedhasbegunplay()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_breplicatedhasbegunplay(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.GameStateBase)
  return target;
}

size_t GameStateBase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.GameStateBase)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string spectatorClassName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_spectatorclassname());
    }

    // optional string gameModeClassName = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gamemodeclassname());
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional bool bReplicatedHasBegunPlay = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional float replicatedWorldTimeSeconds = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameStateBase::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameStateBase::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameStateBase::GetClassData() const { return &_class_data_; }


void GameStateBase::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameStateBase*>(&to_msg);
  auto& from = static_cast<const GameStateBase&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.GameStateBase)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_spectatorclassname(from._internal_spectatorclassname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_gamemodeclassname(from._internal_gamemodeclassname());
    }
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  if (cached_has_bits & 0x0000000cu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.breplicatedhasbegunplay_ = from._impl_.breplicatedhasbegunplay_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.replicatedworldtimeseconds_ = from._impl_.replicatedworldtimeseconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameStateBase::CopyFrom(const GameStateBase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.GameStateBase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameStateBase::IsInitialized() const {
  return true;
}

void GameStateBase::InternalSwap(GameStateBase* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.spectatorclassname_, lhs_arena,
      &other->_impl_.spectatorclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gamemodeclassname_, lhs_arena,
      &other->_impl_.gamemodeclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameStateBase, _impl_.replicatedworldtimeseconds_)
      + sizeof(GameStateBase::_impl_.replicatedworldtimeseconds_)
      - PROTOBUF_FIELD_OFFSET(GameStateBase, _impl_.removed_)>(
          reinterpret_cast<char*>(&_impl_.removed_),
          reinterpret_cast<char*>(&other->_impl_.removed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameStateBase::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace unrealpb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::unrealpb::FVector*
Arena::CreateMaybeMessage< ::unrealpb::FVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FVector >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::UnrealObjectRef_GuidCachedObject*
Arena::CreateMaybeMessage< ::unrealpb::UnrealObjectRef_GuidCachedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::UnrealObjectRef_GuidCachedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::UnrealObjectRef*
Arena::CreateMaybeMessage< ::unrealpb::UnrealObjectRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::UnrealObjectRef >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ActorComponentRef*
Arena::CreateMaybeMessage< ::unrealpb::ActorComponentRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ActorComponentRef >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::RemoteFunctionMessage*
Arena::CreateMaybeMessage< ::unrealpb::RemoteFunctionMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::RemoteFunctionMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SpawnObjectMessage*
Arena::CreateMaybeMessage< ::unrealpb::SpawnObjectMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SpawnObjectMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ActorState*
Arena::CreateMaybeMessage< ::unrealpb::ActorState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ActorState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ActorComponentState*
Arena::CreateMaybeMessage< ::unrealpb::ActorComponentState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ActorComponentState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SceneComponentState*
Arena::CreateMaybeMessage< ::unrealpb::SceneComponentState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SceneComponentState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::RootMotionMontage*
Arena::CreateMaybeMessage< ::unrealpb::RootMotionMontage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::RootMotionMontage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::BasedMovementInfo*
Arena::CreateMaybeMessage< ::unrealpb::BasedMovementInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::BasedMovementInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::CharacterState*
Arena::CreateMaybeMessage< ::unrealpb::CharacterState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::CharacterState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Character_ServerMovePacked_Params*
Arena::CreateMaybeMessage< ::unrealpb::Character_ServerMovePacked_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Character_ServerMovePacked_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Character_ClientMoveResponsePacked_Params*
Arena::CreateMaybeMessage< ::unrealpb::Character_ClientMoveResponsePacked_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Character_ClientMoveResponsePacked_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerState*
Arena::CreateMaybeMessage< ::unrealpb::PlayerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ControllerState*
Arena::CreateMaybeMessage< ::unrealpb::ControllerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ControllerState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Controller_ClientSetLocation_Params*
Arena::CreateMaybeMessage< ::unrealpb::Controller_ClientSetLocation_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Controller_ClientSetLocation_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Controller_ClientSetRotation_Params*
Arena::CreateMaybeMessage< ::unrealpb::Controller_ClientSetRotation_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Controller_ClientSetRotation_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerControllerState*
Arena::CreateMaybeMessage< ::unrealpb::PlayerControllerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerControllerState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ServerUpdateCamera_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ServerUpdateCamera_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ServerUpdateCamera_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientSetHUD_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientSetHUD_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientSetHUD_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientSetViewTarget_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientSetViewTarget_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientSetViewTarget_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientEnableNetworkVoice_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientEnableNetworkVoice_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientEnableNetworkVoice_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientCapBandwidth_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientCapBandwidth_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientCapBandwidth_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientRestart_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientRestart_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientRestart_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientSetCameraMode_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientSetCameraMode_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientSetCameraMode_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientRetryClientRestart_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientRetryClientRestart_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientRetryClientRestart_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ServerSetSpectatorLocation_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ServerSetSpectatorLocation_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ServerSetSpectatorLocation_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ServerAcknowledgePossession_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ServerAcknowledgePossession_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ServerAcknowledgePossession_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::GameStateBase*
Arena::CreateMaybeMessage< ::unrealpb::GameStateBase >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::GameStateBase >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
